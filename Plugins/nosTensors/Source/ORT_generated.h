// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_FBS_H_
#define FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "array"

namespace onnxruntime {
namespace fbs {

struct Shape;
struct ShapeBuilder;
struct TShape;

struct Dimension;
struct DimensionBuilder;
struct TDimension;

struct DimensionValue;
struct DimensionValueBuilder;
struct TDimensionValue;

struct TensorTypeAndShape;
struct TensorTypeAndShapeBuilder;
struct TTensorTypeAndShape;

struct MapType;
struct MapTypeBuilder;
struct TMapType;

struct SequenceType;
struct SequenceTypeBuilder;
struct TSequenceType;

struct EdgeEnd;

struct NodeEdge;
struct NodeEdgeBuilder;
struct TNodeEdge;

struct Node;
struct NodeBuilder;
struct TNode;

struct ValueInfo;
struct ValueInfoBuilder;
struct TValueInfo;

struct TypeInfo;
struct TypeInfoBuilder;
struct TTypeInfo;

struct OperatorSetId;
struct OperatorSetIdBuilder;
struct TOperatorSetId;

struct Tensor;
struct TensorBuilder;
struct TTensor;

struct SparseTensor;
struct SparseTensorBuilder;
struct TSparseTensor;

struct Attribute;
struct AttributeBuilder;
struct TAttribute;

struct NodesToOptimizeIndices;
struct NodesToOptimizeIndicesBuilder;
struct TNodesToOptimizeIndices;

struct DeprecatedNodeIndexAndKernelDefHash;
struct DeprecatedNodeIndexAndKernelDefHashBuilder;
struct TDeprecatedNodeIndexAndKernelDefHash;

struct RuntimeOptimizationRecord;
struct RuntimeOptimizationRecordBuilder;
struct TRuntimeOptimizationRecord;

struct RuntimeOptimizationRecordContainerEntry;
struct RuntimeOptimizationRecordContainerEntryBuilder;
struct TRuntimeOptimizationRecordContainerEntry;

struct RuntimeOptimizations;
struct RuntimeOptimizationsBuilder;
struct TRuntimeOptimizations;

struct Graph;
struct GraphBuilder;
struct TGraph;

struct StringStringEntry;
struct StringStringEntryBuilder;
struct TStringStringEntry;

struct Model;
struct ModelBuilder;
struct TModel;

struct DeprecatedKernelCreateInfos;
struct DeprecatedKernelCreateInfosBuilder;
struct TDeprecatedKernelCreateInfos;

struct DeprecatedSubGraphSessionState;
struct DeprecatedSubGraphSessionStateBuilder;
struct TDeprecatedSubGraphSessionState;

struct DeprecatedSessionState;
struct DeprecatedSessionStateBuilder;
struct TDeprecatedSessionState;

struct ArgTypeAndIndex;
struct ArgTypeAndIndexBuilder;
struct TArgTypeAndIndex;

struct KernelTypeStrArgsEntry;
struct KernelTypeStrArgsEntryBuilder;
struct TKernelTypeStrArgsEntry;

struct OpIdKernelTypeStrArgsEntry;
struct OpIdKernelTypeStrArgsEntryBuilder;
struct TOpIdKernelTypeStrArgsEntry;

struct KernelTypeStrResolver;
struct KernelTypeStrResolverBuilder;
struct TKernelTypeStrResolver;

struct InferenceSession;
struct InferenceSessionBuilder;
struct TInferenceSession;

bool operator==(const TShape &lhs, const TShape &rhs);
bool operator!=(const TShape &lhs, const TShape &rhs);
bool operator==(const TDimension &lhs, const TDimension &rhs);
bool operator!=(const TDimension &lhs, const TDimension &rhs);
bool operator==(const TDimensionValue &lhs, const TDimensionValue &rhs);
bool operator!=(const TDimensionValue &lhs, const TDimensionValue &rhs);
bool operator==(const TTensorTypeAndShape &lhs, const TTensorTypeAndShape &rhs);
bool operator!=(const TTensorTypeAndShape &lhs, const TTensorTypeAndShape &rhs);
bool operator==(const TMapType &lhs, const TMapType &rhs);
bool operator!=(const TMapType &lhs, const TMapType &rhs);
bool operator==(const TSequenceType &lhs, const TSequenceType &rhs);
bool operator!=(const TSequenceType &lhs, const TSequenceType &rhs);
bool operator==(const EdgeEnd &lhs, const EdgeEnd &rhs);
bool operator!=(const EdgeEnd &lhs, const EdgeEnd &rhs);
bool operator==(const TNodeEdge &lhs, const TNodeEdge &rhs);
bool operator!=(const TNodeEdge &lhs, const TNodeEdge &rhs);
bool operator==(const TNode &lhs, const TNode &rhs);
bool operator!=(const TNode &lhs, const TNode &rhs);
bool operator==(const TValueInfo &lhs, const TValueInfo &rhs);
bool operator!=(const TValueInfo &lhs, const TValueInfo &rhs);
bool operator==(const TTypeInfo &lhs, const TTypeInfo &rhs);
bool operator!=(const TTypeInfo &lhs, const TTypeInfo &rhs);
bool operator==(const TOperatorSetId &lhs, const TOperatorSetId &rhs);
bool operator!=(const TOperatorSetId &lhs, const TOperatorSetId &rhs);
bool operator==(const TTensor &lhs, const TTensor &rhs);
bool operator!=(const TTensor &lhs, const TTensor &rhs);
bool operator==(const TSparseTensor &lhs, const TSparseTensor &rhs);
bool operator!=(const TSparseTensor &lhs, const TSparseTensor &rhs);
bool operator==(const TAttribute &lhs, const TAttribute &rhs);
bool operator!=(const TAttribute &lhs, const TAttribute &rhs);
bool operator==(const TNodesToOptimizeIndices &lhs, const TNodesToOptimizeIndices &rhs);
bool operator!=(const TNodesToOptimizeIndices &lhs, const TNodesToOptimizeIndices &rhs);
bool operator==(const TDeprecatedNodeIndexAndKernelDefHash &lhs, const TDeprecatedNodeIndexAndKernelDefHash &rhs);
bool operator!=(const TDeprecatedNodeIndexAndKernelDefHash &lhs, const TDeprecatedNodeIndexAndKernelDefHash &rhs);
bool operator==(const TRuntimeOptimizationRecord &lhs, const TRuntimeOptimizationRecord &rhs);
bool operator!=(const TRuntimeOptimizationRecord &lhs, const TRuntimeOptimizationRecord &rhs);
bool operator==(const TRuntimeOptimizationRecordContainerEntry &lhs, const TRuntimeOptimizationRecordContainerEntry &rhs);
bool operator!=(const TRuntimeOptimizationRecordContainerEntry &lhs, const TRuntimeOptimizationRecordContainerEntry &rhs);
bool operator==(const TRuntimeOptimizations &lhs, const TRuntimeOptimizations &rhs);
bool operator!=(const TRuntimeOptimizations &lhs, const TRuntimeOptimizations &rhs);
bool operator==(const TGraph &lhs, const TGraph &rhs);
bool operator!=(const TGraph &lhs, const TGraph &rhs);
bool operator==(const TStringStringEntry &lhs, const TStringStringEntry &rhs);
bool operator!=(const TStringStringEntry &lhs, const TStringStringEntry &rhs);
bool operator==(const TModel &lhs, const TModel &rhs);
bool operator!=(const TModel &lhs, const TModel &rhs);
bool operator==(const TDeprecatedKernelCreateInfos &lhs, const TDeprecatedKernelCreateInfos &rhs);
bool operator!=(const TDeprecatedKernelCreateInfos &lhs, const TDeprecatedKernelCreateInfos &rhs);
bool operator==(const TDeprecatedSubGraphSessionState &lhs, const TDeprecatedSubGraphSessionState &rhs);
bool operator!=(const TDeprecatedSubGraphSessionState &lhs, const TDeprecatedSubGraphSessionState &rhs);
bool operator==(const TDeprecatedSessionState &lhs, const TDeprecatedSessionState &rhs);
bool operator!=(const TDeprecatedSessionState &lhs, const TDeprecatedSessionState &rhs);
bool operator==(const TArgTypeAndIndex &lhs, const TArgTypeAndIndex &rhs);
bool operator!=(const TArgTypeAndIndex &lhs, const TArgTypeAndIndex &rhs);
bool operator==(const TKernelTypeStrArgsEntry &lhs, const TKernelTypeStrArgsEntry &rhs);
bool operator!=(const TKernelTypeStrArgsEntry &lhs, const TKernelTypeStrArgsEntry &rhs);
bool operator==(const TOpIdKernelTypeStrArgsEntry &lhs, const TOpIdKernelTypeStrArgsEntry &rhs);
bool operator!=(const TOpIdKernelTypeStrArgsEntry &lhs, const TOpIdKernelTypeStrArgsEntry &rhs);
bool operator==(const TKernelTypeStrResolver &lhs, const TKernelTypeStrResolver &rhs);
bool operator!=(const TKernelTypeStrResolver &lhs, const TKernelTypeStrResolver &rhs);
bool operator==(const TInferenceSession &lhs, const TInferenceSession &rhs);
bool operator!=(const TInferenceSession &lhs, const TInferenceSession &rhs);

inline const ::flatbuffers::TypeTable *ShapeTypeTable();

inline const ::flatbuffers::TypeTable *DimensionTypeTable();

inline const ::flatbuffers::TypeTable *DimensionValueTypeTable();

inline const ::flatbuffers::TypeTable *TensorTypeAndShapeTypeTable();

inline const ::flatbuffers::TypeTable *MapTypeTypeTable();

inline const ::flatbuffers::TypeTable *SequenceTypeTypeTable();

inline const ::flatbuffers::TypeTable *EdgeEndTypeTable();

inline const ::flatbuffers::TypeTable *NodeEdgeTypeTable();

inline const ::flatbuffers::TypeTable *NodeTypeTable();

inline const ::flatbuffers::TypeTable *ValueInfoTypeTable();

inline const ::flatbuffers::TypeTable *TypeInfoTypeTable();

inline const ::flatbuffers::TypeTable *OperatorSetIdTypeTable();

inline const ::flatbuffers::TypeTable *TensorTypeTable();

inline const ::flatbuffers::TypeTable *SparseTensorTypeTable();

inline const ::flatbuffers::TypeTable *AttributeTypeTable();

inline const ::flatbuffers::TypeTable *NodesToOptimizeIndicesTypeTable();

inline const ::flatbuffers::TypeTable *DeprecatedNodeIndexAndKernelDefHashTypeTable();

inline const ::flatbuffers::TypeTable *RuntimeOptimizationRecordTypeTable();

inline const ::flatbuffers::TypeTable *RuntimeOptimizationRecordContainerEntryTypeTable();

inline const ::flatbuffers::TypeTable *RuntimeOptimizationsTypeTable();

inline const ::flatbuffers::TypeTable *GraphTypeTable();

inline const ::flatbuffers::TypeTable *StringStringEntryTypeTable();

inline const ::flatbuffers::TypeTable *ModelTypeTable();

inline const ::flatbuffers::TypeTable *DeprecatedKernelCreateInfosTypeTable();

inline const ::flatbuffers::TypeTable *DeprecatedSubGraphSessionStateTypeTable();

inline const ::flatbuffers::TypeTable *DeprecatedSessionStateTypeTable();

inline const ::flatbuffers::TypeTable *ArgTypeAndIndexTypeTable();

inline const ::flatbuffers::TypeTable *KernelTypeStrArgsEntryTypeTable();

inline const ::flatbuffers::TypeTable *OpIdKernelTypeStrArgsEntryTypeTable();

inline const ::flatbuffers::TypeTable *KernelTypeStrResolverTypeTable();

inline const ::flatbuffers::TypeTable *InferenceSessionTypeTable();

enum class AttributeType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  INT = 2,
  STRING = 3,
  TENSOR = 4,
  GRAPH = 5,
  FLOATS = 6,
  INTS = 7,
  STRINGS = 8,
  TENSORS = 9,
  GRAPHS = 10,
  SPARSE_TENSOR = 11,
  SPARSE_TENSORS = 12,
  MIN = UNDEFINED,
  MAX = SPARSE_TENSORS
};

inline const AttributeType (&EnumValuesAttributeType())[13] {
  static const AttributeType values[] = {
    AttributeType::UNDEFINED,
    AttributeType::FLOAT,
    AttributeType::INT,
    AttributeType::STRING,
    AttributeType::TENSOR,
    AttributeType::GRAPH,
    AttributeType::FLOATS,
    AttributeType::INTS,
    AttributeType::STRINGS,
    AttributeType::TENSORS,
    AttributeType::GRAPHS,
    AttributeType::SPARSE_TENSOR,
    AttributeType::SPARSE_TENSORS
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[14] = {
    "UNDEFINED",
    "FLOAT",
    "INT",
    "STRING",
    "TENSOR",
    "GRAPH",
    "FLOATS",
    "INTS",
    "STRINGS",
    "TENSORS",
    "GRAPHS",
    "SPARSE_TENSOR",
    "SPARSE_TENSORS",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (::flatbuffers::IsOutRange(e, AttributeType::UNDEFINED, AttributeType::SPARSE_TENSORS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

enum class DimensionValueType : int8_t {
  UNKNOWN = 0,
  VALUE = 1,
  PARAM = 2,
  MIN = UNKNOWN,
  MAX = PARAM
};

inline const DimensionValueType (&EnumValuesDimensionValueType())[3] {
  static const DimensionValueType values[] = {
    DimensionValueType::UNKNOWN,
    DimensionValueType::VALUE,
    DimensionValueType::PARAM
  };
  return values;
}

inline const char * const *EnumNamesDimensionValueType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "VALUE",
    "PARAM",
    nullptr
  };
  return names;
}

inline const char *EnumNameDimensionValueType(DimensionValueType e) {
  if (::flatbuffers::IsOutRange(e, DimensionValueType::UNKNOWN, DimensionValueType::PARAM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionValueType()[index];
}

enum class TensorDataType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  UINT8 = 2,
  INT8 = 3,
  UINT16 = 4,
  INT16 = 5,
  INT32 = 6,
  INT64 = 7,
  STRING = 8,
  BOOL = 9,
  FLOAT16 = 10,
  DOUBLE = 11,
  UINT32 = 12,
  UINT64 = 13,
  COMPLEX64 = 14,
  COMPLEX128 = 15,
  BFLOAT16 = 16,
  FLOAT8E4M3FN = 17,
  FLOAT8E4M3FNUZ = 18,
  FLOAT8E5M2 = 19,
  FLOAT8E5M2FNUZ = 20,
  MIN = UNDEFINED,
  MAX = FLOAT8E5M2FNUZ
};

inline const TensorDataType (&EnumValuesTensorDataType())[21] {
  static const TensorDataType values[] = {
    TensorDataType::UNDEFINED,
    TensorDataType::FLOAT,
    TensorDataType::UINT8,
    TensorDataType::INT8,
    TensorDataType::UINT16,
    TensorDataType::INT16,
    TensorDataType::INT32,
    TensorDataType::INT64,
    TensorDataType::STRING,
    TensorDataType::BOOL,
    TensorDataType::FLOAT16,
    TensorDataType::DOUBLE,
    TensorDataType::UINT32,
    TensorDataType::UINT64,
    TensorDataType::COMPLEX64,
    TensorDataType::COMPLEX128,
    TensorDataType::BFLOAT16,
    TensorDataType::FLOAT8E4M3FN,
    TensorDataType::FLOAT8E4M3FNUZ,
    TensorDataType::FLOAT8E5M2,
    TensorDataType::FLOAT8E5M2FNUZ
  };
  return values;
}

inline const char * const *EnumNamesTensorDataType() {
  static const char * const names[22] = {
    "UNDEFINED",
    "FLOAT",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "INT32",
    "INT64",
    "STRING",
    "BOOL",
    "FLOAT16",
    "DOUBLE",
    "UINT32",
    "UINT64",
    "COMPLEX64",
    "COMPLEX128",
    "BFLOAT16",
    "FLOAT8E4M3FN",
    "FLOAT8E4M3FNUZ",
    "FLOAT8E5M2",
    "FLOAT8E5M2FNUZ",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorDataType(TensorDataType e) {
  if (::flatbuffers::IsOutRange(e, TensorDataType::UNDEFINED, TensorDataType::FLOAT8E5M2FNUZ)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorDataType()[index];
}

enum class NodeType : int32_t {
  Primitive = 0,
  Fused = 1,
  MIN = Primitive,
  MAX = Fused
};

inline const NodeType (&EnumValuesNodeType())[2] {
  static const NodeType values[] = {
    NodeType::Primitive,
    NodeType::Fused
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[3] = {
    "Primitive",
    "Fused",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (::flatbuffers::IsOutRange(e, NodeType::Primitive, NodeType::Fused)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

enum class TypeInfoValue : uint8_t {
  NONE = 0,
  tensor_type = 1,
  sequence_type = 2,
  map_type = 3,
  MIN = NONE,
  MAX = map_type
};

inline const TypeInfoValue (&EnumValuesTypeInfoValue())[4] {
  static const TypeInfoValue values[] = {
    TypeInfoValue::NONE,
    TypeInfoValue::tensor_type,
    TypeInfoValue::sequence_type,
    TypeInfoValue::map_type
  };
  return values;
}

inline const char * const *EnumNamesTypeInfoValue() {
  static const char * const names[5] = {
    "NONE",
    "tensor_type",
    "sequence_type",
    "map_type",
    nullptr
  };
  return names;
}

inline const char *EnumNameTypeInfoValue(TypeInfoValue e) {
  if (::flatbuffers::IsOutRange(e, TypeInfoValue::NONE, TypeInfoValue::map_type)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTypeInfoValue()[index];
}

template<typename T> struct TypeInfoValueTraits {
  static const TypeInfoValue enum_value = TypeInfoValue::NONE;
};

template<> struct TypeInfoValueTraits<onnxruntime::fbs::TensorTypeAndShape> {
  static const TypeInfoValue enum_value = TypeInfoValue::tensor_type;
};

template<> struct TypeInfoValueTraits<onnxruntime::fbs::SequenceType> {
  static const TypeInfoValue enum_value = TypeInfoValue::sequence_type;
};

template<> struct TypeInfoValueTraits<onnxruntime::fbs::MapType> {
  static const TypeInfoValue enum_value = TypeInfoValue::map_type;
};

template<typename T> struct TypeInfoValueUnionTraits {
  static const TypeInfoValue enum_value = TypeInfoValue::NONE;
};

template<> struct TypeInfoValueUnionTraits<onnxruntime::fbs::TTensorTypeAndShape> {
  static const TypeInfoValue enum_value = TypeInfoValue::tensor_type;
};

template<> struct TypeInfoValueUnionTraits<onnxruntime::fbs::TSequenceType> {
  static const TypeInfoValue enum_value = TypeInfoValue::sequence_type;
};

template<> struct TypeInfoValueUnionTraits<onnxruntime::fbs::TMapType> {
  static const TypeInfoValue enum_value = TypeInfoValue::map_type;
};

struct TypeInfoValueUnion {
  TypeInfoValue type;
  void *value;

  TypeInfoValueUnion() : type(TypeInfoValue::NONE), value(nullptr) {}
  TypeInfoValueUnion(TypeInfoValueUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(TypeInfoValue::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  TypeInfoValueUnion(const TypeInfoValueUnion &);
  TypeInfoValueUnion &operator=(const TypeInfoValueUnion &u)
    { TypeInfoValueUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  TypeInfoValueUnion &operator=(TypeInfoValueUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~TypeInfoValueUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = TypeInfoValueUnionTraits<RT>::enum_value;
    if (type != TypeInfoValue::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, TypeInfoValue type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  onnxruntime::fbs::TTensorTypeAndShape *Astensor_type() {
    return type == TypeInfoValue::tensor_type ?
      reinterpret_cast<onnxruntime::fbs::TTensorTypeAndShape *>(value) : nullptr;
  }
  const onnxruntime::fbs::TTensorTypeAndShape *Astensor_type() const {
    return type == TypeInfoValue::tensor_type ?
      reinterpret_cast<const onnxruntime::fbs::TTensorTypeAndShape *>(value) : nullptr;
  }
  onnxruntime::fbs::TSequenceType *Assequence_type() {
    return type == TypeInfoValue::sequence_type ?
      reinterpret_cast<onnxruntime::fbs::TSequenceType *>(value) : nullptr;
  }
  const onnxruntime::fbs::TSequenceType *Assequence_type() const {
    return type == TypeInfoValue::sequence_type ?
      reinterpret_cast<const onnxruntime::fbs::TSequenceType *>(value) : nullptr;
  }
  onnxruntime::fbs::TMapType *Asmap_type() {
    return type == TypeInfoValue::map_type ?
      reinterpret_cast<onnxruntime::fbs::TMapType *>(value) : nullptr;
  }
  const onnxruntime::fbs::TMapType *Asmap_type() const {
    return type == TypeInfoValue::map_type ?
      reinterpret_cast<const onnxruntime::fbs::TMapType *>(value) : nullptr;
  }
};


inline bool operator==(const TypeInfoValueUnion &lhs, const TypeInfoValueUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case TypeInfoValue::NONE: {
      return true;
    }
    case TypeInfoValue::tensor_type: {
      return *(reinterpret_cast<const onnxruntime::fbs::TTensorTypeAndShape *>(lhs.value)) ==
             *(reinterpret_cast<const onnxruntime::fbs::TTensorTypeAndShape *>(rhs.value));
    }
    case TypeInfoValue::sequence_type: {
      return *(reinterpret_cast<const onnxruntime::fbs::TSequenceType *>(lhs.value)) ==
             *(reinterpret_cast<const onnxruntime::fbs::TSequenceType *>(rhs.value));
    }
    case TypeInfoValue::map_type: {
      return *(reinterpret_cast<const onnxruntime::fbs::TMapType *>(lhs.value)) ==
             *(reinterpret_cast<const onnxruntime::fbs::TMapType *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const TypeInfoValueUnion &lhs, const TypeInfoValueUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyTypeInfoValue(::flatbuffers::Verifier &verifier, const void *obj, TypeInfoValue type);
bool VerifyTypeInfoValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<TypeInfoValue> *types);

enum class ArgType : int8_t {
  INPUT = 0,
  OUTPUT = 1,
  MIN = INPUT,
  MAX = OUTPUT
};

inline const ArgType (&EnumValuesArgType())[2] {
  static const ArgType values[] = {
    ArgType::INPUT,
    ArgType::OUTPUT
  };
  return values;
}

inline const char * const *EnumNamesArgType() {
  static const char * const names[3] = {
    "INPUT",
    "OUTPUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameArgType(ArgType e) {
  if (::flatbuffers::IsOutRange(e, ArgType::INPUT, ArgType::OUTPUT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArgType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EdgeEnd FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t node_index_;
  int32_t src_arg_index_;
  int32_t dst_arg_index_;

 public:
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EdgeEndTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.EdgeEnd";
  }
  EdgeEnd()
      : node_index_(0),
        src_arg_index_(0),
        dst_arg_index_(0) {
  }
  EdgeEnd(uint32_t _node_index, int32_t _src_arg_index, int32_t _dst_arg_index)
      : node_index_(::flatbuffers::EndianScalar(_node_index)),
        src_arg_index_(::flatbuffers::EndianScalar(_src_arg_index)),
        dst_arg_index_(::flatbuffers::EndianScalar(_dst_arg_index)) {
  }
  uint32_t node_index() const {
    return ::flatbuffers::EndianScalar(node_index_);
  }
  void mutate_node_index(uint32_t _node_index) {
    ::flatbuffers::WriteScalar(&node_index_, _node_index);
  }
  int32_t src_arg_index() const {
    return ::flatbuffers::EndianScalar(src_arg_index_);
  }
  void mutate_src_arg_index(int32_t _src_arg_index) {
    ::flatbuffers::WriteScalar(&src_arg_index_, _src_arg_index);
  }
  int32_t dst_arg_index() const {
    return ::flatbuffers::EndianScalar(dst_arg_index_);
  }
  void mutate_dst_arg_index(int32_t _dst_arg_index) {
    ::flatbuffers::WriteScalar(&dst_arg_index_, _dst_arg_index);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return node_index();
    else if constexpr (Index == 1) return src_arg_index();
    else if constexpr (Index == 2) return dst_arg_index();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(EdgeEnd, 12);

inline bool operator==(const EdgeEnd &lhs, const EdgeEnd &rhs) {
  return
      (lhs.node_index() == rhs.node_index()) &&
      (lhs.src_arg_index() == rhs.src_arg_index()) &&
      (lhs.dst_arg_index() == rhs.dst_arg_index());
}

inline bool operator!=(const EdgeEnd &lhs, const EdgeEnd &rhs) {
    return !(lhs == rhs);
}


struct EdgeEnd::Traits {
  using type = EdgeEnd;
  static constexpr auto name = "EdgeEnd";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.EdgeEnd";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "node_index",
    "src_arg_index",
    "dst_arg_index"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct TShape : public ::flatbuffers::NativeTable {
  typedef Shape TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TShape";
  }
  std::vector<std::unique_ptr<onnxruntime::fbs::TDimension>> dim{};
  TShape() = default;
  TShape(const TShape &o);
  TShape(TShape&&) FLATBUFFERS_NOEXCEPT = default;
  TShape &operator=(TShape o) FLATBUFFERS_NOEXCEPT;
};

struct Shape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TShape NativeTableType;
  typedef ShapeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShapeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.Shape";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>> *dim() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>> *>(VT_DIM);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>> *mutable_dim() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>> *>(VT_DIM);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return dim();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.VerifyVectorOfTables(dim()) &&
           verifier.EndTable();
  }
  TShape *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TShape *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Shape> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TShape* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeBuilder {
  typedef Shape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>>> dim) {
    fbb_.AddOffset(Shape::VT_DIM, dim);
  }
  explicit ShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Shape> CreateShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>>> dim = 0) {
  ShapeBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

struct Shape::Traits {
  using type = Shape;
  static auto constexpr Create = CreateShape;
  static constexpr auto name = "Shape";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.Shape";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "dim"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Shape> CreateShapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>> *dim = nullptr) {
  auto dim__ = dim ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>>(*dim) : 0;
  return onnxruntime::fbs::CreateShape(
      _fbb,
      dim__);
}

::flatbuffers::Offset<Shape> CreateShape(::flatbuffers::FlatBufferBuilder &_fbb, const TShape *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TDimension : public ::flatbuffers::NativeTable {
  typedef Dimension TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TDimension";
  }
  std::unique_ptr<onnxruntime::fbs::TDimensionValue> value{};
  std::string denotation{};
  TDimension() = default;
  TDimension(const TDimension &o);
  TDimension(TDimension&&) FLATBUFFERS_NOEXCEPT = default;
  TDimension &operator=(TDimension o) FLATBUFFERS_NOEXCEPT;
};

struct Dimension FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDimension NativeTableType;
  typedef DimensionBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DimensionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.Dimension";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DENOTATION = 6
  };
  const onnxruntime::fbs::DimensionValue *value() const {
    return GetPointer<const onnxruntime::fbs::DimensionValue *>(VT_VALUE);
  }
  onnxruntime::fbs::DimensionValue *mutable_value() {
    return GetPointer<onnxruntime::fbs::DimensionValue *>(VT_VALUE);
  }
  const ::flatbuffers::String *denotation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DENOTATION);
  }
  ::flatbuffers::String *mutable_denotation() {
    return GetPointer<::flatbuffers::String *>(VT_DENOTATION);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return value();
    else if constexpr (Index == 1) return denotation();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           verifier.EndTable();
  }
  TDimension *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDimension *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Dimension> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDimension* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DimensionBuilder {
  typedef Dimension Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<onnxruntime::fbs::DimensionValue> value) {
    fbb_.AddOffset(Dimension::VT_VALUE, value);
  }
  void add_denotation(::flatbuffers::Offset<::flatbuffers::String> denotation) {
    fbb_.AddOffset(Dimension::VT_DENOTATION, denotation);
  }
  explicit DimensionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dimension>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Dimension> CreateDimension(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::DimensionValue> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> denotation = 0) {
  DimensionBuilder builder_(_fbb);
  builder_.add_denotation(denotation);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Dimension::Traits {
  using type = Dimension;
  static auto constexpr Create = CreateDimension;
  static constexpr auto name = "Dimension";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.Dimension";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "value",
    "denotation"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Dimension> CreateDimensionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::DimensionValue> value = 0,
    const char *denotation = nullptr) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnxruntime::fbs::CreateDimension(
      _fbb,
      value,
      denotation__);
}

::flatbuffers::Offset<Dimension> CreateDimension(::flatbuffers::FlatBufferBuilder &_fbb, const TDimension *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TDimensionValue : public ::flatbuffers::NativeTable {
  typedef DimensionValue TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TDimensionValue";
  }
  onnxruntime::fbs::DimensionValueType dim_type = onnxruntime::fbs::DimensionValueType::UNKNOWN;
  int64_t dim_value = 0;
  std::string dim_param{};
};

struct DimensionValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDimensionValue NativeTableType;
  typedef DimensionValueBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DimensionValueTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.DimensionValue";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM_TYPE = 4,
    VT_DIM_VALUE = 6,
    VT_DIM_PARAM = 8
  };
  onnxruntime::fbs::DimensionValueType dim_type() const {
    return static_cast<onnxruntime::fbs::DimensionValueType>(GetField<int8_t>(VT_DIM_TYPE, 0));
  }
  bool mutate_dim_type(onnxruntime::fbs::DimensionValueType _dim_type = static_cast<onnxruntime::fbs::DimensionValueType>(0)) {
    return SetField<int8_t>(VT_DIM_TYPE, static_cast<int8_t>(_dim_type), 0);
  }
  int64_t dim_value() const {
    return GetField<int64_t>(VT_DIM_VALUE, 0);
  }
  bool mutate_dim_value(int64_t _dim_value = 0) {
    return SetField<int64_t>(VT_DIM_VALUE, _dim_value, 0);
  }
  const ::flatbuffers::String *dim_param() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIM_PARAM);
  }
  ::flatbuffers::String *mutable_dim_param() {
    return GetPointer<::flatbuffers::String *>(VT_DIM_PARAM);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return dim_type();
    else if constexpr (Index == 1) return dim_value();
    else if constexpr (Index == 2) return dim_param();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DIM_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_DIM_VALUE, 8) &&
           VerifyOffset(verifier, VT_DIM_PARAM) &&
           verifier.VerifyString(dim_param()) &&
           verifier.EndTable();
  }
  TDimensionValue *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDimensionValue *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DimensionValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDimensionValue* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DimensionValueBuilder {
  typedef DimensionValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim_type(onnxruntime::fbs::DimensionValueType dim_type) {
    fbb_.AddElement<int8_t>(DimensionValue::VT_DIM_TYPE, static_cast<int8_t>(dim_type), 0);
  }
  void add_dim_value(int64_t dim_value) {
    fbb_.AddElement<int64_t>(DimensionValue::VT_DIM_VALUE, dim_value, 0);
  }
  void add_dim_param(::flatbuffers::Offset<::flatbuffers::String> dim_param) {
    fbb_.AddOffset(DimensionValue::VT_DIM_PARAM, dim_param);
  }
  explicit DimensionValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DimensionValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DimensionValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DimensionValue> CreateDimensionValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::DimensionValueType dim_type = onnxruntime::fbs::DimensionValueType::UNKNOWN,
    int64_t dim_value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dim_param = 0) {
  DimensionValueBuilder builder_(_fbb);
  builder_.add_dim_value(dim_value);
  builder_.add_dim_param(dim_param);
  builder_.add_dim_type(dim_type);
  return builder_.Finish();
}

struct DimensionValue::Traits {
  using type = DimensionValue;
  static auto constexpr Create = CreateDimensionValue;
  static constexpr auto name = "DimensionValue";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.DimensionValue";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "dim_type",
    "dim_value",
    "dim_param"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DimensionValue> CreateDimensionValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::DimensionValueType dim_type = onnxruntime::fbs::DimensionValueType::UNKNOWN,
    int64_t dim_value = 0,
    const char *dim_param = nullptr) {
  auto dim_param__ = dim_param ? _fbb.CreateString(dim_param) : 0;
  return onnxruntime::fbs::CreateDimensionValue(
      _fbb,
      dim_type,
      dim_value,
      dim_param__);
}

::flatbuffers::Offset<DimensionValue> CreateDimensionValue(::flatbuffers::FlatBufferBuilder &_fbb, const TDimensionValue *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TTensorTypeAndShape : public ::flatbuffers::NativeTable {
  typedef TensorTypeAndShape TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TTensorTypeAndShape";
  }
  onnxruntime::fbs::TensorDataType elem_type = onnxruntime::fbs::TensorDataType::UNDEFINED;
  std::unique_ptr<onnxruntime::fbs::TShape> shape{};
  TTensorTypeAndShape() = default;
  TTensorTypeAndShape(const TTensorTypeAndShape &o);
  TTensorTypeAndShape(TTensorTypeAndShape&&) FLATBUFFERS_NOEXCEPT = default;
  TTensorTypeAndShape &operator=(TTensorTypeAndShape o) FLATBUFFERS_NOEXCEPT;
};

struct TensorTypeAndShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TTensorTypeAndShape NativeTableType;
  typedef TensorTypeAndShapeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorTypeAndShapeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TensorTypeAndShape";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4,
    VT_SHAPE = 6
  };
  onnxruntime::fbs::TensorDataType elem_type() const {
    return static_cast<onnxruntime::fbs::TensorDataType>(GetField<int32_t>(VT_ELEM_TYPE, 0));
  }
  bool mutate_elem_type(onnxruntime::fbs::TensorDataType _elem_type = static_cast<onnxruntime::fbs::TensorDataType>(0)) {
    return SetField<int32_t>(VT_ELEM_TYPE, static_cast<int32_t>(_elem_type), 0);
  }
  const onnxruntime::fbs::Shape *shape() const {
    return GetPointer<const onnxruntime::fbs::Shape *>(VT_SHAPE);
  }
  onnxruntime::fbs::Shape *mutable_shape() {
    return GetPointer<onnxruntime::fbs::Shape *>(VT_SHAPE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return elem_type();
    else if constexpr (Index == 1) return shape();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEM_TYPE, 4) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
  TTensorTypeAndShape *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TTensorTypeAndShape *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TensorTypeAndShape> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTensorTypeAndShape* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorTypeAndShapeBuilder {
  typedef TensorTypeAndShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type(onnxruntime::fbs::TensorDataType elem_type) {
    fbb_.AddElement<int32_t>(TensorTypeAndShape::VT_ELEM_TYPE, static_cast<int32_t>(elem_type), 0);
  }
  void add_shape(::flatbuffers::Offset<onnxruntime::fbs::Shape> shape) {
    fbb_.AddOffset(TensorTypeAndShape::VT_SHAPE, shape);
  }
  explicit TensorTypeAndShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorTypeAndShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorTypeAndShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorTypeAndShape> CreateTensorTypeAndShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::TensorDataType elem_type = onnxruntime::fbs::TensorDataType::UNDEFINED,
    ::flatbuffers::Offset<onnxruntime::fbs::Shape> shape = 0) {
  TensorTypeAndShapeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct TensorTypeAndShape::Traits {
  using type = TensorTypeAndShape;
  static auto constexpr Create = CreateTensorTypeAndShape;
  static constexpr auto name = "TensorTypeAndShape";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.TensorTypeAndShape";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "elem_type",
    "shape"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

::flatbuffers::Offset<TensorTypeAndShape> CreateTensorTypeAndShape(::flatbuffers::FlatBufferBuilder &_fbb, const TTensorTypeAndShape *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TMapType : public ::flatbuffers::NativeTable {
  typedef MapType TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TMapType";
  }
  onnxruntime::fbs::TensorDataType key_type = onnxruntime::fbs::TensorDataType::UNDEFINED;
  std::unique_ptr<onnxruntime::fbs::TTypeInfo> value_type{};
  TMapType() = default;
  TMapType(const TMapType &o);
  TMapType(TMapType&&) FLATBUFFERS_NOEXCEPT = default;
  TMapType &operator=(TMapType o) FLATBUFFERS_NOEXCEPT;
};

struct MapType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TMapType NativeTableType;
  typedef MapTypeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapTypeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.MapType";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY_TYPE = 4,
    VT_VALUE_TYPE = 6
  };
  onnxruntime::fbs::TensorDataType key_type() const {
    return static_cast<onnxruntime::fbs::TensorDataType>(GetField<int32_t>(VT_KEY_TYPE, 0));
  }
  bool mutate_key_type(onnxruntime::fbs::TensorDataType _key_type = static_cast<onnxruntime::fbs::TensorDataType>(0)) {
    return SetField<int32_t>(VT_KEY_TYPE, static_cast<int32_t>(_key_type), 0);
  }
  const onnxruntime::fbs::TypeInfo *value_type() const {
    return GetPointer<const onnxruntime::fbs::TypeInfo *>(VT_VALUE_TYPE);
  }
  onnxruntime::fbs::TypeInfo *mutable_value_type() {
    return GetPointer<onnxruntime::fbs::TypeInfo *>(VT_VALUE_TYPE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return key_type();
    else if constexpr (Index == 1) return value_type();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_TYPE, 4) &&
           VerifyOffset(verifier, VT_VALUE_TYPE) &&
           verifier.VerifyTable(value_type()) &&
           verifier.EndTable();
  }
  TMapType *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TMapType *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MapType> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TMapType* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapTypeBuilder {
  typedef MapType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key_type(onnxruntime::fbs::TensorDataType key_type) {
    fbb_.AddElement<int32_t>(MapType::VT_KEY_TYPE, static_cast<int32_t>(key_type), 0);
  }
  void add_value_type(::flatbuffers::Offset<onnxruntime::fbs::TypeInfo> value_type) {
    fbb_.AddOffset(MapType::VT_VALUE_TYPE, value_type);
  }
  explicit MapTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MapType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MapType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MapType> CreateMapType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::TensorDataType key_type = onnxruntime::fbs::TensorDataType::UNDEFINED,
    ::flatbuffers::Offset<onnxruntime::fbs::TypeInfo> value_type = 0) {
  MapTypeBuilder builder_(_fbb);
  builder_.add_value_type(value_type);
  builder_.add_key_type(key_type);
  return builder_.Finish();
}

struct MapType::Traits {
  using type = MapType;
  static auto constexpr Create = CreateMapType;
  static constexpr auto name = "MapType";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.MapType";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "key_type",
    "value_type"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

::flatbuffers::Offset<MapType> CreateMapType(::flatbuffers::FlatBufferBuilder &_fbb, const TMapType *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TSequenceType : public ::flatbuffers::NativeTable {
  typedef SequenceType TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TSequenceType";
  }
  std::unique_ptr<onnxruntime::fbs::TTypeInfo> elem_type{};
  TSequenceType() = default;
  TSequenceType(const TSequenceType &o);
  TSequenceType(TSequenceType&&) FLATBUFFERS_NOEXCEPT = default;
  TSequenceType &operator=(TSequenceType o) FLATBUFFERS_NOEXCEPT;
};

struct SequenceType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TSequenceType NativeTableType;
  typedef SequenceTypeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SequenceTypeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.SequenceType";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4
  };
  const onnxruntime::fbs::TypeInfo *elem_type() const {
    return GetPointer<const onnxruntime::fbs::TypeInfo *>(VT_ELEM_TYPE);
  }
  onnxruntime::fbs::TypeInfo *mutable_elem_type() {
    return GetPointer<onnxruntime::fbs::TypeInfo *>(VT_ELEM_TYPE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return elem_type();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEM_TYPE) &&
           verifier.VerifyTable(elem_type()) &&
           verifier.EndTable();
  }
  TSequenceType *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TSequenceType *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SequenceType> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TSequenceType* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SequenceTypeBuilder {
  typedef SequenceType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elem_type(::flatbuffers::Offset<onnxruntime::fbs::TypeInfo> elem_type) {
    fbb_.AddOffset(SequenceType::VT_ELEM_TYPE, elem_type);
  }
  explicit SequenceTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SequenceType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SequenceType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SequenceType> CreateSequenceType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::TypeInfo> elem_type = 0) {
  SequenceTypeBuilder builder_(_fbb);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct SequenceType::Traits {
  using type = SequenceType;
  static auto constexpr Create = CreateSequenceType;
  static constexpr auto name = "SequenceType";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.SequenceType";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "elem_type"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

::flatbuffers::Offset<SequenceType> CreateSequenceType(::flatbuffers::FlatBufferBuilder &_fbb, const TSequenceType *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TNodeEdge : public ::flatbuffers::NativeTable {
  typedef NodeEdge TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TNodeEdge";
  }
  uint32_t node_index = 0;
  std::vector<onnxruntime::fbs::EdgeEnd> input_edges{};
  std::vector<onnxruntime::fbs::EdgeEnd> output_edges{};
};

struct NodeEdge FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TNodeEdge NativeTableType;
  typedef NodeEdgeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NodeEdgeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.NodeEdge";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDEX = 4,
    VT_INPUT_EDGES = 6,
    VT_OUTPUT_EDGES = 8
  };
  uint32_t node_index() const {
    return GetField<uint32_t>(VT_NODE_INDEX, 0);
  }
  bool mutate_node_index(uint32_t _node_index = 0) {
    return SetField<uint32_t>(VT_NODE_INDEX, _node_index, 0);
  }
  const ::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *input_edges() const {
    return GetPointer<const ::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *>(VT_INPUT_EDGES);
  }
  ::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *mutable_input_edges() {
    return GetPointer<::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *>(VT_INPUT_EDGES);
  }
  const ::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *output_edges() const {
    return GetPointer<const ::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *>(VT_OUTPUT_EDGES);
  }
  ::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *mutable_output_edges() {
    return GetPointer<::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *>(VT_OUTPUT_EDGES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return node_index();
    else if constexpr (Index == 1) return input_edges();
    else if constexpr (Index == 2) return output_edges();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NODE_INDEX, 4) &&
           VerifyOffset(verifier, VT_INPUT_EDGES) &&
           verifier.VerifyVector(input_edges()) &&
           VerifyOffset(verifier, VT_OUTPUT_EDGES) &&
           verifier.VerifyVector(output_edges()) &&
           verifier.EndTable();
  }
  TNodeEdge *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TNodeEdge *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NodeEdge> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TNodeEdge* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeEdgeBuilder {
  typedef NodeEdge Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_index(uint32_t node_index) {
    fbb_.AddElement<uint32_t>(NodeEdge::VT_NODE_INDEX, node_index, 0);
  }
  void add_input_edges(::flatbuffers::Offset<::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *>> input_edges) {
    fbb_.AddOffset(NodeEdge::VT_INPUT_EDGES, input_edges);
  }
  void add_output_edges(::flatbuffers::Offset<::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *>> output_edges) {
    fbb_.AddOffset(NodeEdge::VT_OUTPUT_EDGES, output_edges);
  }
  explicit NodeEdgeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NodeEdge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NodeEdge>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NodeEdge> CreateNodeEdge(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t node_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *>> input_edges = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *>> output_edges = 0) {
  NodeEdgeBuilder builder_(_fbb);
  builder_.add_output_edges(output_edges);
  builder_.add_input_edges(input_edges);
  builder_.add_node_index(node_index);
  return builder_.Finish();
}

struct NodeEdge::Traits {
  using type = NodeEdge;
  static auto constexpr Create = CreateNodeEdge;
  static constexpr auto name = "NodeEdge";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.NodeEdge";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "node_index",
    "input_edges",
    "output_edges"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<NodeEdge> CreateNodeEdgeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t node_index = 0,
    const std::vector<onnxruntime::fbs::EdgeEnd> *input_edges = nullptr,
    const std::vector<onnxruntime::fbs::EdgeEnd> *output_edges = nullptr) {
  auto input_edges__ = input_edges ? _fbb.CreateVectorOfStructs<onnxruntime::fbs::EdgeEnd>(*input_edges) : 0;
  auto output_edges__ = output_edges ? _fbb.CreateVectorOfStructs<onnxruntime::fbs::EdgeEnd>(*output_edges) : 0;
  return onnxruntime::fbs::CreateNodeEdge(
      _fbb,
      node_index,
      input_edges__,
      output_edges__);
}

::flatbuffers::Offset<NodeEdge> CreateNodeEdge(::flatbuffers::FlatBufferBuilder &_fbb, const TNodeEdge *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TNode : public ::flatbuffers::NativeTable {
  typedef Node TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TNode";
  }
  std::string name{};
  std::string doc_string{};
  std::string domain{};
  int32_t since_version = 0;
  uint32_t index = 0;
  std::string op_type{};
  onnxruntime::fbs::NodeType type = onnxruntime::fbs::NodeType::Primitive;
  std::string execution_provider_type{};
  std::vector<std::string> inputs{};
  std::vector<std::string> outputs{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TAttribute>> attributes{};
  std::vector<int32_t> input_arg_counts{};
  std::vector<std::string> implicit_inputs{};
  TNode() = default;
  TNode(const TNode &o);
  TNode(TNode&&) FLATBUFFERS_NOEXCEPT = default;
  TNode &operator=(TNode o) FLATBUFFERS_NOEXCEPT;
};

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TNode NativeTableType;
  typedef NodeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NodeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.Node";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_DOMAIN = 8,
    VT_SINCE_VERSION = 10,
    VT_INDEX = 12,
    VT_OP_TYPE = 14,
    VT_TYPE = 16,
    VT_EXECUTION_PROVIDER_TYPE = 18,
    VT_INPUTS = 20,
    VT_OUTPUTS = 22,
    VT_ATTRIBUTES = 24,
    VT_INPUT_ARG_COUNTS = 26,
    VT_IMPLICIT_INPUTS = 28
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  int32_t since_version() const {
    return GetField<int32_t>(VT_SINCE_VERSION, 0);
  }
  bool mutate_since_version(int32_t _since_version = 0) {
    return SetField<int32_t>(VT_SINCE_VERSION, _since_version, 0);
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool mutate_index(uint32_t _index = 0) {
    return SetField<uint32_t>(VT_INDEX, _index, 0);
  }
  const ::flatbuffers::String *op_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OP_TYPE);
  }
  ::flatbuffers::String *mutable_op_type() {
    return GetPointer<::flatbuffers::String *>(VT_OP_TYPE);
  }
  onnxruntime::fbs::NodeType type() const {
    return static_cast<onnxruntime::fbs::NodeType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool mutate_type(onnxruntime::fbs::NodeType _type = static_cast<onnxruntime::fbs::NodeType>(0)) {
    return SetField<int32_t>(VT_TYPE, static_cast<int32_t>(_type), 0);
  }
  const ::flatbuffers::String *execution_provider_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXECUTION_PROVIDER_TYPE);
  }
  ::flatbuffers::String *mutable_execution_provider_type() {
    return GetPointer<::flatbuffers::String *>(VT_EXECUTION_PROVIDER_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_inputs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_outputs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>> *>(VT_ATTRIBUTES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>> *mutable_attributes() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::Vector<int32_t> *input_arg_counts() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUT_ARG_COUNTS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_input_arg_counts() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_INPUT_ARG_COUNTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *implicit_inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_IMPLICIT_INPUTS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_implicit_inputs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_IMPLICIT_INPUTS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return doc_string();
    else if constexpr (Index == 2) return domain();
    else if constexpr (Index == 3) return since_version();
    else if constexpr (Index == 4) return index();
    else if constexpr (Index == 5) return op_type();
    else if constexpr (Index == 6) return type();
    else if constexpr (Index == 7) return execution_provider_type();
    else if constexpr (Index == 8) return inputs();
    else if constexpr (Index == 9) return outputs();
    else if constexpr (Index == 10) return attributes();
    else if constexpr (Index == 11) return input_arg_counts();
    else if constexpr (Index == 12) return implicit_inputs();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int32_t>(verifier, VT_SINCE_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_INDEX, 4) &&
           VerifyOffset(verifier, VT_OP_TYPE) &&
           verifier.VerifyString(op_type()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_EXECUTION_PROVIDER_TYPE) &&
           verifier.VerifyString(execution_provider_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_INPUT_ARG_COUNTS) &&
           verifier.VerifyVector(input_arg_counts()) &&
           VerifyOffset(verifier, VT_IMPLICIT_INPUTS) &&
           verifier.VerifyVector(implicit_inputs()) &&
           verifier.VerifyVectorOfStrings(implicit_inputs()) &&
           verifier.EndTable();
  }
  TNode *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TNode *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Node> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TNode* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Node::VT_DOC_STRING, doc_string);
  }
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(Node::VT_DOMAIN, domain);
  }
  void add_since_version(int32_t since_version) {
    fbb_.AddElement<int32_t>(Node::VT_SINCE_VERSION, since_version, 0);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(Node::VT_INDEX, index, 0);
  }
  void add_op_type(::flatbuffers::Offset<::flatbuffers::String> op_type) {
    fbb_.AddOffset(Node::VT_OP_TYPE, op_type);
  }
  void add_type(onnxruntime::fbs::NodeType type) {
    fbb_.AddElement<int32_t>(Node::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_execution_provider_type(::flatbuffers::Offset<::flatbuffers::String> execution_provider_type) {
    fbb_.AddOffset(Node::VT_EXECUTION_PROVIDER_TYPE, execution_provider_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Node::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Node::VT_OUTPUTS, outputs);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>>> attributes) {
    fbb_.AddOffset(Node::VT_ATTRIBUTES, attributes);
  }
  void add_input_arg_counts(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> input_arg_counts) {
    fbb_.AddOffset(Node::VT_INPUT_ARG_COUNTS, input_arg_counts);
  }
  void add_implicit_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> implicit_inputs) {
    fbb_.AddOffset(Node::VT_IMPLICIT_INPUTS, implicit_inputs);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    int32_t since_version = 0,
    uint32_t index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> op_type = 0,
    onnxruntime::fbs::NodeType type = onnxruntime::fbs::NodeType::Primitive,
    ::flatbuffers::Offset<::flatbuffers::String> execution_provider_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> input_arg_counts = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> implicit_inputs = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_implicit_inputs(implicit_inputs);
  builder_.add_input_arg_counts(input_arg_counts);
  builder_.add_attributes(attributes);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_execution_provider_type(execution_provider_type);
  builder_.add_type(type);
  builder_.add_op_type(op_type);
  builder_.add_index(index);
  builder_.add_since_version(since_version);
  builder_.add_domain(domain);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Node::Traits {
  using type = Node;
  static auto constexpr Create = CreateNode;
  static constexpr auto name = "Node";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.Node";
  static constexpr size_t fields_number = 13;
  static constexpr std::array<const char *, fields_number> field_names = {
    "name",
    "doc_string",
    "domain",
    "since_version",
    "index",
    "op_type",
    "type",
    "execution_provider_type",
    "inputs",
    "outputs",
    "attributes",
    "input_arg_counts",
    "implicit_inputs"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    const char *domain = nullptr,
    int32_t since_version = 0,
    uint32_t index = 0,
    const char *op_type = nullptr,
    onnxruntime::fbs::NodeType type = onnxruntime::fbs::NodeType::Primitive,
    const char *execution_provider_type = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>> *attributes = nullptr,
    const std::vector<int32_t> *input_arg_counts = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *implicit_inputs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto op_type__ = op_type ? _fbb.CreateString(op_type) : 0;
  auto execution_provider_type__ = execution_provider_type ? _fbb.CreateString(execution_provider_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputs) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>>(*attributes) : 0;
  auto input_arg_counts__ = input_arg_counts ? _fbb.CreateVector<int32_t>(*input_arg_counts) : 0;
  auto implicit_inputs__ = implicit_inputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*implicit_inputs) : 0;
  return onnxruntime::fbs::CreateNode(
      _fbb,
      name__,
      doc_string__,
      domain__,
      since_version,
      index,
      op_type__,
      type,
      execution_provider_type__,
      inputs__,
      outputs__,
      attributes__,
      input_arg_counts__,
      implicit_inputs__);
}

::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const TNode *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TValueInfo : public ::flatbuffers::NativeTable {
  typedef ValueInfo TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TValueInfo";
  }
  std::string name{};
  std::string doc_string{};
  std::unique_ptr<onnxruntime::fbs::TTypeInfo> type{};
  TValueInfo() = default;
  TValueInfo(const TValueInfo &o);
  TValueInfo(TValueInfo&&) FLATBUFFERS_NOEXCEPT = default;
  TValueInfo &operator=(TValueInfo o) FLATBUFFERS_NOEXCEPT;
};

struct ValueInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TValueInfo NativeTableType;
  typedef ValueInfoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ValueInfoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.ValueInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_TYPE = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const onnxruntime::fbs::TypeInfo *type() const {
    return GetPointer<const onnxruntime::fbs::TypeInfo *>(VT_TYPE);
  }
  onnxruntime::fbs::TypeInfo *mutable_type() {
    return GetPointer<onnxruntime::fbs::TypeInfo *>(VT_TYPE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return doc_string();
    else if constexpr (Index == 2) return type();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
  TValueInfo *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TValueInfo *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ValueInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TValueInfo* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ValueInfoBuilder {
  typedef ValueInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ValueInfo::VT_NAME, name);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(ValueInfo::VT_DOC_STRING, doc_string);
  }
  void add_type(::flatbuffers::Offset<onnxruntime::fbs::TypeInfo> type) {
    fbb_.AddOffset(ValueInfo::VT_TYPE, type);
  }
  explicit ValueInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueInfo> CreateValueInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::TypeInfo> type = 0) {
  ValueInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

struct ValueInfo::Traits {
  using type = ValueInfo;
  static auto constexpr Create = CreateValueInfo;
  static constexpr auto name = "ValueInfo";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.ValueInfo";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "name",
    "doc_string",
    "type"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ValueInfo> CreateValueInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    ::flatbuffers::Offset<onnxruntime::fbs::TypeInfo> type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  return onnxruntime::fbs::CreateValueInfo(
      _fbb,
      name__,
      doc_string__,
      type);
}

::flatbuffers::Offset<ValueInfo> CreateValueInfo(::flatbuffers::FlatBufferBuilder &_fbb, const TValueInfo *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TTypeInfo : public ::flatbuffers::NativeTable {
  typedef TypeInfo TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TTypeInfo";
  }
  std::string denotation{};
  onnxruntime::fbs::TypeInfoValueUnion value{};
};

struct TypeInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TTypeInfo NativeTableType;
  typedef TypeInfoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TypeInfoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TypeInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DENOTATION = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *denotation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DENOTATION);
  }
  ::flatbuffers::String *mutable_denotation() {
    return GetPointer<::flatbuffers::String *>(VT_DENOTATION);
  }
  onnxruntime::fbs::TypeInfoValue value_type() const {
    return static_cast<onnxruntime::fbs::TypeInfoValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const onnxruntime::fbs::TensorTypeAndShape *value_as_tensor_type() const {
    return value_type() == onnxruntime::fbs::TypeInfoValue::tensor_type ? static_cast<const onnxruntime::fbs::TensorTypeAndShape *>(value()) : nullptr;
  }
  const onnxruntime::fbs::SequenceType *value_as_sequence_type() const {
    return value_type() == onnxruntime::fbs::TypeInfoValue::sequence_type ? static_cast<const onnxruntime::fbs::SequenceType *>(value()) : nullptr;
  }
  const onnxruntime::fbs::MapType *value_as_map_type() const {
    return value_type() == onnxruntime::fbs::TypeInfoValue::map_type ? static_cast<const onnxruntime::fbs::MapType *>(value()) : nullptr;
  }
  void *mutable_value() {
    return GetPointer<void *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return denotation();
    else if constexpr (Index == 1) return value_type();
    else if constexpr (Index == 2) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyTypeInfoValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  TTypeInfo *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TTypeInfo *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TypeInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTypeInfo* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const onnxruntime::fbs::TensorTypeAndShape *TypeInfo::value_as<onnxruntime::fbs::TensorTypeAndShape>() const {
  return value_as_tensor_type();
}

template<> inline const onnxruntime::fbs::SequenceType *TypeInfo::value_as<onnxruntime::fbs::SequenceType>() const {
  return value_as_sequence_type();
}

template<> inline const onnxruntime::fbs::MapType *TypeInfo::value_as<onnxruntime::fbs::MapType>() const {
  return value_as_map_type();
}

struct TypeInfoBuilder {
  typedef TypeInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_denotation(::flatbuffers::Offset<::flatbuffers::String> denotation) {
    fbb_.AddOffset(TypeInfo::VT_DENOTATION, denotation);
  }
  void add_value_type(onnxruntime::fbs::TypeInfoValue value_type) {
    fbb_.AddElement<uint8_t>(TypeInfo::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(TypeInfo::VT_VALUE, value);
  }
  explicit TypeInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TypeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TypeInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TypeInfo> CreateTypeInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> denotation = 0,
    onnxruntime::fbs::TypeInfoValue value_type = onnxruntime::fbs::TypeInfoValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  TypeInfoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_denotation(denotation);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct TypeInfo::Traits {
  using type = TypeInfo;
  static auto constexpr Create = CreateTypeInfo;
  static constexpr auto name = "TypeInfo";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.TypeInfo";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "denotation",
    "value_type",
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<TypeInfo> CreateTypeInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *denotation = nullptr,
    onnxruntime::fbs::TypeInfoValue value_type = onnxruntime::fbs::TypeInfoValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnxruntime::fbs::CreateTypeInfo(
      _fbb,
      denotation__,
      value_type,
      value);
}

::flatbuffers::Offset<TypeInfo> CreateTypeInfo(::flatbuffers::FlatBufferBuilder &_fbb, const TTypeInfo *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOperatorSetId : public ::flatbuffers::NativeTable {
  typedef OperatorSetId TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TOperatorSetId";
  }
  std::string domain{};
  int64_t version = 0;
};

struct OperatorSetId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TOperatorSetId NativeTableType;
  typedef OperatorSetIdBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OperatorSetIdTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.OperatorSetId";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOMAIN = 4,
    VT_VERSION = 6
  };
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool mutate_version(int64_t _version = 0) {
    return SetField<int64_t>(VT_VERSION, _version, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return domain();
    else if constexpr (Index == 1) return version();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_VERSION, 8) &&
           verifier.EndTable();
  }
  TOperatorSetId *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOperatorSetId *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OperatorSetId> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TOperatorSetId* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorSetIdBuilder {
  typedef OperatorSetId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(OperatorSetId::VT_DOMAIN, domain);
  }
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(OperatorSetId::VT_VERSION, version, 0);
  }
  explicit OperatorSetIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OperatorSetId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OperatorSetId>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OperatorSetId> CreateOperatorSetId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    int64_t version = 0) {
  OperatorSetIdBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_domain(domain);
  return builder_.Finish();
}

struct OperatorSetId::Traits {
  using type = OperatorSetId;
  static auto constexpr Create = CreateOperatorSetId;
  static constexpr auto name = "OperatorSetId";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.OperatorSetId";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "domain",
    "version"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<OperatorSetId> CreateOperatorSetIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *domain = nullptr,
    int64_t version = 0) {
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  return onnxruntime::fbs::CreateOperatorSetId(
      _fbb,
      domain__,
      version);
}

::flatbuffers::Offset<OperatorSetId> CreateOperatorSetId(::flatbuffers::FlatBufferBuilder &_fbb, const TOperatorSetId *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TTensor : public ::flatbuffers::NativeTable {
  typedef Tensor TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TTensor";
  }
  std::string name{};
  std::string doc_string{};
  std::vector<int64_t> dims{};
  onnxruntime::fbs::TensorDataType data_type = onnxruntime::fbs::TensorDataType::UNDEFINED;
  std::vector<uint8_t> raw_data{};
  std::vector<std::string> string_data{};
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TTensor NativeTableType;
  typedef TensorBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.Tensor";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_DIMS = 8,
    VT_DATA_TYPE = 10,
    VT_RAW_DATA = 12,
    VT_STRING_DATA = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_dims() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  onnxruntime::fbs::TensorDataType data_type() const {
    return static_cast<onnxruntime::fbs::TensorDataType>(GetField<int32_t>(VT_DATA_TYPE, 0));
  }
  bool mutate_data_type(onnxruntime::fbs::TensorDataType _data_type = static_cast<onnxruntime::fbs::TensorDataType>(0)) {
    return SetField<int32_t>(VT_DATA_TYPE, static_cast<int32_t>(_data_type), 0);
  }
  const ::flatbuffers::Vector<uint8_t> *raw_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_raw_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *string_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_DATA);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_string_data() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return doc_string();
    else if constexpr (Index == 2) return dims();
    else if constexpr (Index == 3) return data_type();
    else if constexpr (Index == 4) return raw_data();
    else if constexpr (Index == 5) return string_data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE, 4) &&
           VerifyOffset(verifier, VT_RAW_DATA) &&
           verifier.VerifyVector(raw_data()) &&
           VerifyOffset(verifier, VT_STRING_DATA) &&
           verifier.VerifyVector(string_data()) &&
           verifier.VerifyVectorOfStrings(string_data()) &&
           verifier.EndTable();
  }
  TTensor *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TTensor *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Tensor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTensor* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Tensor::VT_DOC_STRING, doc_string);
  }
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(Tensor::VT_DIMS, dims);
  }
  void add_data_type(onnxruntime::fbs::TensorDataType data_type) {
    fbb_.AddElement<int32_t>(Tensor::VT_DATA_TYPE, static_cast<int32_t>(data_type), 0);
  }
  void add_raw_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw_data) {
    fbb_.AddOffset(Tensor::VT_RAW_DATA, raw_data);
  }
  void add_string_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_data) {
    fbb_.AddOffset(Tensor::VT_STRING_DATA, string_data);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0,
    onnxruntime::fbs::TensorDataType data_type = onnxruntime::fbs::TensorDataType::UNDEFINED,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_data = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_string_data(string_data);
  builder_.add_raw_data(raw_data);
  builder_.add_data_type(data_type);
  builder_.add_dims(dims);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Tensor::Traits {
  using type = Tensor;
  static auto constexpr Create = CreateTensor;
  static constexpr auto name = "Tensor";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.Tensor";
  static constexpr size_t fields_number = 6;
  static constexpr std::array<const char *, fields_number> field_names = {
    "name",
    "doc_string",
    "dims",
    "data_type",
    "raw_data",
    "string_data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    const std::vector<int64_t> *dims = nullptr,
    onnxruntime::fbs::TensorDataType data_type = onnxruntime::fbs::TensorDataType::UNDEFINED,
    const std::vector<uint8_t> *raw_data = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *string_data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  auto raw_data__ = raw_data ? _fbb.CreateVector<uint8_t>(*raw_data) : 0;
  auto string_data__ = string_data ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*string_data) : 0;
  return onnxruntime::fbs::CreateTensor(
      _fbb,
      name__,
      doc_string__,
      dims__,
      data_type,
      raw_data__,
      string_data__);
}

::flatbuffers::Offset<Tensor> CreateTensor(::flatbuffers::FlatBufferBuilder &_fbb, const TTensor *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TSparseTensor : public ::flatbuffers::NativeTable {
  typedef SparseTensor TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TSparseTensor";
  }
  std::unique_ptr<onnxruntime::fbs::TTensor> values{};
  std::unique_ptr<onnxruntime::fbs::TTensor> indices{};
  std::vector<int64_t> dims{};
  TSparseTensor() = default;
  TSparseTensor(const TSparseTensor &o);
  TSparseTensor(TSparseTensor&&) FLATBUFFERS_NOEXCEPT = default;
  TSparseTensor &operator=(TSparseTensor o) FLATBUFFERS_NOEXCEPT;
};

struct SparseTensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TSparseTensor NativeTableType;
  typedef SparseTensorBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseTensorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.SparseTensor";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4,
    VT_INDICES = 6,
    VT_DIMS = 8
  };
  const onnxruntime::fbs::Tensor *values() const {
    return GetPointer<const onnxruntime::fbs::Tensor *>(VT_VALUES);
  }
  onnxruntime::fbs::Tensor *mutable_values() {
    return GetPointer<onnxruntime::fbs::Tensor *>(VT_VALUES);
  }
  const onnxruntime::fbs::Tensor *indices() const {
    return GetPointer<const onnxruntime::fbs::Tensor *>(VT_INDICES);
  }
  onnxruntime::fbs::Tensor *mutable_indices() {
    return GetPointer<onnxruntime::fbs::Tensor *>(VT_INDICES);
  }
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_dims() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return values();
    else if constexpr (Index == 1) return indices();
    else if constexpr (Index == 2) return dims();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyTable(values()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyTable(indices()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  TSparseTensor *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TSparseTensor *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SparseTensor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TSparseTensor* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseTensorBuilder {
  typedef SparseTensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<onnxruntime::fbs::Tensor> values) {
    fbb_.AddOffset(SparseTensor::VT_VALUES, values);
  }
  void add_indices(::flatbuffers::Offset<onnxruntime::fbs::Tensor> indices) {
    fbb_.AddOffset(SparseTensor::VT_INDICES, indices);
  }
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(SparseTensor::VT_DIMS, dims);
  }
  explicit SparseTensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparseTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparseTensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparseTensor> CreateSparseTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::Tensor> values = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::Tensor> indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0) {
  SparseTensorBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_indices(indices);
  builder_.add_values(values);
  return builder_.Finish();
}

struct SparseTensor::Traits {
  using type = SparseTensor;
  static auto constexpr Create = CreateSparseTensor;
  static constexpr auto name = "SparseTensor";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.SparseTensor";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "values",
    "indices",
    "dims"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<SparseTensor> CreateSparseTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::Tensor> values = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::Tensor> indices = 0,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return onnxruntime::fbs::CreateSparseTensor(
      _fbb,
      values,
      indices,
      dims__);
}

::flatbuffers::Offset<SparseTensor> CreateSparseTensor(::flatbuffers::FlatBufferBuilder &_fbb, const TSparseTensor *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TAttribute : public ::flatbuffers::NativeTable {
  typedef Attribute TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TAttribute";
  }
  std::string name{};
  std::string doc_string{};
  onnxruntime::fbs::AttributeType type = onnxruntime::fbs::AttributeType::UNDEFINED;
  float f = 0.0f;
  int64_t i = 0;
  std::string s{};
  std::unique_ptr<onnxruntime::fbs::TTensor> t{};
  std::unique_ptr<onnxruntime::fbs::TGraph> g{};
  std::vector<float> floats{};
  std::vector<int64_t> ints{};
  std::vector<std::string> strings{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TTensor>> tensors{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TGraph>> graphs{};
  TAttribute() = default;
  TAttribute(const TAttribute &o);
  TAttribute(TAttribute&&) FLATBUFFERS_NOEXCEPT = default;
  TAttribute &operator=(TAttribute o) FLATBUFFERS_NOEXCEPT;
};

struct Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TAttribute NativeTableType;
  typedef AttributeBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AttributeTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.Attribute";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_TYPE = 8,
    VT_F = 10,
    VT_I = 12,
    VT_S = 14,
    VT_T = 16,
    VT_G = 18,
    VT_FLOATS = 20,
    VT_INTS = 22,
    VT_STRINGS = 24,
    VT_TENSORS = 26,
    VT_GRAPHS = 28
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  onnxruntime::fbs::AttributeType type() const {
    return static_cast<onnxruntime::fbs::AttributeType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool mutate_type(onnxruntime::fbs::AttributeType _type = static_cast<onnxruntime::fbs::AttributeType>(0)) {
    return SetField<int32_t>(VT_TYPE, static_cast<int32_t>(_type), 0);
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  bool mutate_f(float _f = 0.0f) {
    return SetField<float>(VT_F, _f, 0.0f);
  }
  int64_t i() const {
    return GetField<int64_t>(VT_I, 0);
  }
  bool mutate_i(int64_t _i = 0) {
    return SetField<int64_t>(VT_I, _i, 0);
  }
  const ::flatbuffers::String *s() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S);
  }
  ::flatbuffers::String *mutable_s() {
    return GetPointer<::flatbuffers::String *>(VT_S);
  }
  const onnxruntime::fbs::Tensor *t() const {
    return GetPointer<const onnxruntime::fbs::Tensor *>(VT_T);
  }
  onnxruntime::fbs::Tensor *mutable_t() {
    return GetPointer<onnxruntime::fbs::Tensor *>(VT_T);
  }
  const onnxruntime::fbs::Graph *g() const {
    return GetPointer<const onnxruntime::fbs::Graph *>(VT_G);
  }
  onnxruntime::fbs::Graph *mutable_g() {
    return GetPointer<onnxruntime::fbs::Graph *>(VT_G);
  }
  const ::flatbuffers::Vector<float> *floats() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  ::flatbuffers::Vector<float> *mutable_floats() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const ::flatbuffers::Vector<int64_t> *ints() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INTS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_ints() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_INTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_strings() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *>(VT_TENSORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *mutable_tensors() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *>(VT_TENSORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Graph>> *graphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Graph>> *>(VT_GRAPHS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Graph>> *mutable_graphs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Graph>> *>(VT_GRAPHS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return doc_string();
    else if constexpr (Index == 2) return type();
    else if constexpr (Index == 3) return f();
    else if constexpr (Index == 4) return i();
    else if constexpr (Index == 5) return s();
    else if constexpr (Index == 6) return t();
    else if constexpr (Index == 7) return g();
    else if constexpr (Index == 8) return floats();
    else if constexpr (Index == 9) return ints();
    else if constexpr (Index == 10) return strings();
    else if constexpr (Index == 11) return tensors();
    else if constexpr (Index == 12) return graphs();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<float>(verifier, VT_F, 4) &&
           VerifyField<int64_t>(verifier, VT_I, 8) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyTable(t()) &&
           VerifyOffset(verifier, VT_G) &&
           verifier.VerifyTable(g()) &&
           VerifyOffset(verifier, VT_FLOATS) &&
           verifier.VerifyVector(floats()) &&
           VerifyOffset(verifier, VT_INTS) &&
           verifier.VerifyVector(ints()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_GRAPHS) &&
           verifier.VerifyVector(graphs()) &&
           verifier.VerifyVectorOfTables(graphs()) &&
           verifier.EndTable();
  }
  TAttribute *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TAttribute *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Attribute> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TAttribute* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttributeBuilder {
  typedef Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Attribute::VT_NAME, name);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Attribute::VT_DOC_STRING, doc_string);
  }
  void add_type(onnxruntime::fbs::AttributeType type) {
    fbb_.AddElement<int32_t>(Attribute::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(Attribute::VT_F, f, 0.0f);
  }
  void add_i(int64_t i) {
    fbb_.AddElement<int64_t>(Attribute::VT_I, i, 0);
  }
  void add_s(::flatbuffers::Offset<::flatbuffers::String> s) {
    fbb_.AddOffset(Attribute::VT_S, s);
  }
  void add_t(::flatbuffers::Offset<onnxruntime::fbs::Tensor> t) {
    fbb_.AddOffset(Attribute::VT_T, t);
  }
  void add_g(::flatbuffers::Offset<onnxruntime::fbs::Graph> g) {
    fbb_.AddOffset(Attribute::VT_G, g);
  }
  void add_floats(::flatbuffers::Offset<::flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(Attribute::VT_FLOATS, floats);
  }
  void add_ints(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> ints) {
    fbb_.AddOffset(Attribute::VT_INTS, ints);
  }
  void add_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> strings) {
    fbb_.AddOffset(Attribute::VT_STRINGS, strings);
  }
  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>>> tensors) {
    fbb_.AddOffset(Attribute::VT_TENSORS, tensors);
  }
  void add_graphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Graph>>> graphs) {
    fbb_.AddOffset(Attribute::VT_GRAPHS, graphs);
  }
  explicit AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Attribute> CreateAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    onnxruntime::fbs::AttributeType type = onnxruntime::fbs::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    ::flatbuffers::Offset<::flatbuffers::String> s = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::Tensor> t = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::Graph> g = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> floats = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> ints = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> strings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>>> tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Graph>>> graphs = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_i(i);
  builder_.add_graphs(graphs);
  builder_.add_tensors(tensors);
  builder_.add_strings(strings);
  builder_.add_ints(ints);
  builder_.add_floats(floats);
  builder_.add_g(g);
  builder_.add_t(t);
  builder_.add_s(s);
  builder_.add_f(f);
  builder_.add_type(type);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Attribute::Traits {
  using type = Attribute;
  static auto constexpr Create = CreateAttribute;
  static constexpr auto name = "Attribute";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.Attribute";
  static constexpr size_t fields_number = 13;
  static constexpr std::array<const char *, fields_number> field_names = {
    "name",
    "doc_string",
    "type",
    "f",
    "i",
    "s",
    "t",
    "g",
    "floats",
    "ints",
    "strings",
    "tensors",
    "graphs"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Attribute> CreateAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    onnxruntime::fbs::AttributeType type = onnxruntime::fbs::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    const char *s = nullptr,
    ::flatbuffers::Offset<onnxruntime::fbs::Tensor> t = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::Graph> g = 0,
    const std::vector<float> *floats = nullptr,
    const std::vector<int64_t> *ints = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *strings = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *tensors = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::Graph>> *graphs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto s__ = s ? _fbb.CreateString(s) : 0;
  auto floats__ = floats ? _fbb.CreateVector<float>(*floats) : 0;
  auto ints__ = ints ? _fbb.CreateVector<int64_t>(*ints) : 0;
  auto strings__ = strings ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*strings) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>>(*tensors) : 0;
  auto graphs__ = graphs ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Graph>>(*graphs) : 0;
  return onnxruntime::fbs::CreateAttribute(
      _fbb,
      name__,
      doc_string__,
      type,
      f,
      i,
      s__,
      t,
      g,
      floats__,
      ints__,
      strings__,
      tensors__,
      graphs__);
}

::flatbuffers::Offset<Attribute> CreateAttribute(::flatbuffers::FlatBufferBuilder &_fbb, const TAttribute *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TNodesToOptimizeIndices : public ::flatbuffers::NativeTable {
  typedef NodesToOptimizeIndices TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TNodesToOptimizeIndices";
  }
  std::vector<uint32_t> node_indices{};
  uint32_t num_inputs = 0;
  uint32_t num_outputs = 0;
  bool has_variadic_input = false;
  bool has_variadic_output = false;
  uint32_t num_variadic_inputs = 0;
  uint32_t num_variadic_outputs = 0;
};

/// nodes to consider for a runtime optimization
/// see corresponding type in onnxruntime/core/graph/runtime_optimization_record.h
struct NodesToOptimizeIndices FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TNodesToOptimizeIndices NativeTableType;
  typedef NodesToOptimizeIndicesBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NodesToOptimizeIndicesTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.NodesToOptimizeIndices";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDICES = 4,
    VT_NUM_INPUTS = 6,
    VT_NUM_OUTPUTS = 8,
    VT_HAS_VARIADIC_INPUT = 10,
    VT_HAS_VARIADIC_OUTPUT = 12,
    VT_NUM_VARIADIC_INPUTS = 14,
    VT_NUM_VARIADIC_OUTPUTS = 16
  };
  const ::flatbuffers::Vector<uint32_t> *node_indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_NODE_INDICES);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_node_indices() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_NODE_INDICES);
  }
  uint32_t num_inputs() const {
    return GetField<uint32_t>(VT_NUM_INPUTS, 0);
  }
  bool mutate_num_inputs(uint32_t _num_inputs = 0) {
    return SetField<uint32_t>(VT_NUM_INPUTS, _num_inputs, 0);
  }
  uint32_t num_outputs() const {
    return GetField<uint32_t>(VT_NUM_OUTPUTS, 0);
  }
  bool mutate_num_outputs(uint32_t _num_outputs = 0) {
    return SetField<uint32_t>(VT_NUM_OUTPUTS, _num_outputs, 0);
  }
  bool has_variadic_input() const {
    return GetField<uint8_t>(VT_HAS_VARIADIC_INPUT, 0) != 0;
  }
  bool mutate_has_variadic_input(bool _has_variadic_input = 0) {
    return SetField<uint8_t>(VT_HAS_VARIADIC_INPUT, static_cast<uint8_t>(_has_variadic_input), 0);
  }
  bool has_variadic_output() const {
    return GetField<uint8_t>(VT_HAS_VARIADIC_OUTPUT, 0) != 0;
  }
  bool mutate_has_variadic_output(bool _has_variadic_output = 0) {
    return SetField<uint8_t>(VT_HAS_VARIADIC_OUTPUT, static_cast<uint8_t>(_has_variadic_output), 0);
  }
  uint32_t num_variadic_inputs() const {
    return GetField<uint32_t>(VT_NUM_VARIADIC_INPUTS, 0);
  }
  bool mutate_num_variadic_inputs(uint32_t _num_variadic_inputs = 0) {
    return SetField<uint32_t>(VT_NUM_VARIADIC_INPUTS, _num_variadic_inputs, 0);
  }
  uint32_t num_variadic_outputs() const {
    return GetField<uint32_t>(VT_NUM_VARIADIC_OUTPUTS, 0);
  }
  bool mutate_num_variadic_outputs(uint32_t _num_variadic_outputs = 0) {
    return SetField<uint32_t>(VT_NUM_VARIADIC_OUTPUTS, _num_variadic_outputs, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return node_indices();
    else if constexpr (Index == 1) return num_inputs();
    else if constexpr (Index == 2) return num_outputs();
    else if constexpr (Index == 3) return has_variadic_input();
    else if constexpr (Index == 4) return has_variadic_output();
    else if constexpr (Index == 5) return num_variadic_inputs();
    else if constexpr (Index == 6) return num_variadic_outputs();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_INDICES) &&
           verifier.VerifyVector(node_indices()) &&
           VerifyField<uint32_t>(verifier, VT_NUM_INPUTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_NUM_OUTPUTS, 4) &&
           VerifyField<uint8_t>(verifier, VT_HAS_VARIADIC_INPUT, 1) &&
           VerifyField<uint8_t>(verifier, VT_HAS_VARIADIC_OUTPUT, 1) &&
           VerifyField<uint32_t>(verifier, VT_NUM_VARIADIC_INPUTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_NUM_VARIADIC_OUTPUTS, 4) &&
           verifier.EndTable();
  }
  TNodesToOptimizeIndices *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TNodesToOptimizeIndices *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NodesToOptimizeIndices> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TNodesToOptimizeIndices* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodesToOptimizeIndicesBuilder {
  typedef NodesToOptimizeIndices Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> node_indices) {
    fbb_.AddOffset(NodesToOptimizeIndices::VT_NODE_INDICES, node_indices);
  }
  void add_num_inputs(uint32_t num_inputs) {
    fbb_.AddElement<uint32_t>(NodesToOptimizeIndices::VT_NUM_INPUTS, num_inputs, 0);
  }
  void add_num_outputs(uint32_t num_outputs) {
    fbb_.AddElement<uint32_t>(NodesToOptimizeIndices::VT_NUM_OUTPUTS, num_outputs, 0);
  }
  void add_has_variadic_input(bool has_variadic_input) {
    fbb_.AddElement<uint8_t>(NodesToOptimizeIndices::VT_HAS_VARIADIC_INPUT, static_cast<uint8_t>(has_variadic_input), 0);
  }
  void add_has_variadic_output(bool has_variadic_output) {
    fbb_.AddElement<uint8_t>(NodesToOptimizeIndices::VT_HAS_VARIADIC_OUTPUT, static_cast<uint8_t>(has_variadic_output), 0);
  }
  void add_num_variadic_inputs(uint32_t num_variadic_inputs) {
    fbb_.AddElement<uint32_t>(NodesToOptimizeIndices::VT_NUM_VARIADIC_INPUTS, num_variadic_inputs, 0);
  }
  void add_num_variadic_outputs(uint32_t num_variadic_outputs) {
    fbb_.AddElement<uint32_t>(NodesToOptimizeIndices::VT_NUM_VARIADIC_OUTPUTS, num_variadic_outputs, 0);
  }
  explicit NodesToOptimizeIndicesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NodesToOptimizeIndices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NodesToOptimizeIndices>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NodesToOptimizeIndices> CreateNodesToOptimizeIndices(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> node_indices = 0,
    uint32_t num_inputs = 0,
    uint32_t num_outputs = 0,
    bool has_variadic_input = false,
    bool has_variadic_output = false,
    uint32_t num_variadic_inputs = 0,
    uint32_t num_variadic_outputs = 0) {
  NodesToOptimizeIndicesBuilder builder_(_fbb);
  builder_.add_num_variadic_outputs(num_variadic_outputs);
  builder_.add_num_variadic_inputs(num_variadic_inputs);
  builder_.add_num_outputs(num_outputs);
  builder_.add_num_inputs(num_inputs);
  builder_.add_node_indices(node_indices);
  builder_.add_has_variadic_output(has_variadic_output);
  builder_.add_has_variadic_input(has_variadic_input);
  return builder_.Finish();
}

struct NodesToOptimizeIndices::Traits {
  using type = NodesToOptimizeIndices;
  static auto constexpr Create = CreateNodesToOptimizeIndices;
  static constexpr auto name = "NodesToOptimizeIndices";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.NodesToOptimizeIndices";
  static constexpr size_t fields_number = 7;
  static constexpr std::array<const char *, fields_number> field_names = {
    "node_indices",
    "num_inputs",
    "num_outputs",
    "has_variadic_input",
    "has_variadic_output",
    "num_variadic_inputs",
    "num_variadic_outputs"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<NodesToOptimizeIndices> CreateNodesToOptimizeIndicesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *node_indices = nullptr,
    uint32_t num_inputs = 0,
    uint32_t num_outputs = 0,
    bool has_variadic_input = false,
    bool has_variadic_output = false,
    uint32_t num_variadic_inputs = 0,
    uint32_t num_variadic_outputs = 0) {
  auto node_indices__ = node_indices ? _fbb.CreateVector<uint32_t>(*node_indices) : 0;
  return onnxruntime::fbs::CreateNodesToOptimizeIndices(
      _fbb,
      node_indices__,
      num_inputs,
      num_outputs,
      has_variadic_input,
      has_variadic_output,
      num_variadic_inputs,
      num_variadic_outputs);
}

::flatbuffers::Offset<NodesToOptimizeIndices> CreateNodesToOptimizeIndices(::flatbuffers::FlatBufferBuilder &_fbb, const TNodesToOptimizeIndices *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TDeprecatedNodeIndexAndKernelDefHash : public ::flatbuffers::NativeTable {
  typedef DeprecatedNodeIndexAndKernelDefHash TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TDeprecatedNodeIndexAndKernelDefHash";
  }
  uint32_t node_index = 0;
  uint64_t kernel_def_hash = 0;
};

/// deprecated: no longer using kernel def hashes
struct DeprecatedNodeIndexAndKernelDefHash FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDeprecatedNodeIndexAndKernelDefHash NativeTableType;
  typedef DeprecatedNodeIndexAndKernelDefHashBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeprecatedNodeIndexAndKernelDefHashTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.DeprecatedNodeIndexAndKernelDefHash";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDEX = 4,
    VT_KERNEL_DEF_HASH = 6
  };
  uint32_t node_index() const {
    return GetField<uint32_t>(VT_NODE_INDEX, 0);
  }
  bool mutate_node_index(uint32_t _node_index = 0) {
    return SetField<uint32_t>(VT_NODE_INDEX, _node_index, 0);
  }
  uint64_t kernel_def_hash() const {
    return GetField<uint64_t>(VT_KERNEL_DEF_HASH, 0);
  }
  bool mutate_kernel_def_hash(uint64_t _kernel_def_hash = 0) {
    return SetField<uint64_t>(VT_KERNEL_DEF_HASH, _kernel_def_hash, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return node_index();
    else if constexpr (Index == 1) return kernel_def_hash();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NODE_INDEX, 4) &&
           VerifyField<uint64_t>(verifier, VT_KERNEL_DEF_HASH, 8) &&
           verifier.EndTable();
  }
  TDeprecatedNodeIndexAndKernelDefHash *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDeprecatedNodeIndexAndKernelDefHash *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedNodeIndexAndKernelDefHash* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeprecatedNodeIndexAndKernelDefHashBuilder {
  typedef DeprecatedNodeIndexAndKernelDefHash Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_index(uint32_t node_index) {
    fbb_.AddElement<uint32_t>(DeprecatedNodeIndexAndKernelDefHash::VT_NODE_INDEX, node_index, 0);
  }
  void add_kernel_def_hash(uint64_t kernel_def_hash) {
    fbb_.AddElement<uint64_t>(DeprecatedNodeIndexAndKernelDefHash::VT_KERNEL_DEF_HASH, kernel_def_hash, 0);
  }
  explicit DeprecatedNodeIndexAndKernelDefHashBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash> CreateDeprecatedNodeIndexAndKernelDefHash(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t node_index = 0,
    uint64_t kernel_def_hash = 0) {
  DeprecatedNodeIndexAndKernelDefHashBuilder builder_(_fbb);
  builder_.add_kernel_def_hash(kernel_def_hash);
  builder_.add_node_index(node_index);
  return builder_.Finish();
}

struct DeprecatedNodeIndexAndKernelDefHash::Traits {
  using type = DeprecatedNodeIndexAndKernelDefHash;
  static auto constexpr Create = CreateDeprecatedNodeIndexAndKernelDefHash;
  static constexpr auto name = "DeprecatedNodeIndexAndKernelDefHash";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.DeprecatedNodeIndexAndKernelDefHash";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "node_index",
    "kernel_def_hash"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

::flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash> CreateDeprecatedNodeIndexAndKernelDefHash(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedNodeIndexAndKernelDefHash *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TRuntimeOptimizationRecord : public ::flatbuffers::NativeTable {
  typedef RuntimeOptimizationRecord TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TRuntimeOptimizationRecord";
  }
  std::string action_id{};
  std::unique_ptr<onnxruntime::fbs::TNodesToOptimizeIndices> nodes_to_optimize_indices{};
  std::vector<std::string> produced_op_ids{};
  TRuntimeOptimizationRecord() = default;
  TRuntimeOptimizationRecord(const TRuntimeOptimizationRecord &o);
  TRuntimeOptimizationRecord(TRuntimeOptimizationRecord&&) FLATBUFFERS_NOEXCEPT = default;
  TRuntimeOptimizationRecord &operator=(TRuntimeOptimizationRecord o) FLATBUFFERS_NOEXCEPT;
};

/// a single runtime optimization
/// see corresponding type in onnxruntime/core/graph/runtime_optimization_record.h
struct RuntimeOptimizationRecord FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRuntimeOptimizationRecord NativeTableType;
  typedef RuntimeOptimizationRecordBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RuntimeOptimizationRecordTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.RuntimeOptimizationRecord";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION_ID = 4,
    VT_NODES_TO_OPTIMIZE_INDICES = 6,
    VT_PRODUCED_OP_IDS = 10
  };
  const ::flatbuffers::String *action_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTION_ID);
  }
  ::flatbuffers::String *mutable_action_id() {
    return GetPointer<::flatbuffers::String *>(VT_ACTION_ID);
  }
  const onnxruntime::fbs::NodesToOptimizeIndices *nodes_to_optimize_indices() const {
    return GetPointer<const onnxruntime::fbs::NodesToOptimizeIndices *>(VT_NODES_TO_OPTIMIZE_INDICES);
  }
  onnxruntime::fbs::NodesToOptimizeIndices *mutable_nodes_to_optimize_indices() {
    return GetPointer<onnxruntime::fbs::NodesToOptimizeIndices *>(VT_NODES_TO_OPTIMIZE_INDICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *produced_op_ids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PRODUCED_OP_IDS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_produced_op_ids() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PRODUCED_OP_IDS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return action_id();
    else if constexpr (Index == 1) return nodes_to_optimize_indices();
    else if constexpr (Index == 2) return produced_op_ids();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION_ID) &&
           verifier.VerifyString(action_id()) &&
           VerifyOffset(verifier, VT_NODES_TO_OPTIMIZE_INDICES) &&
           verifier.VerifyTable(nodes_to_optimize_indices()) &&
           VerifyOffset(verifier, VT_PRODUCED_OP_IDS) &&
           verifier.VerifyVector(produced_op_ids()) &&
           verifier.VerifyVectorOfStrings(produced_op_ids()) &&
           verifier.EndTable();
  }
  TRuntimeOptimizationRecord *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TRuntimeOptimizationRecord *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RuntimeOptimizationRecord> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizationRecord* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuntimeOptimizationRecordBuilder {
  typedef RuntimeOptimizationRecord Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action_id(::flatbuffers::Offset<::flatbuffers::String> action_id) {
    fbb_.AddOffset(RuntimeOptimizationRecord::VT_ACTION_ID, action_id);
  }
  void add_nodes_to_optimize_indices(::flatbuffers::Offset<onnxruntime::fbs::NodesToOptimizeIndices> nodes_to_optimize_indices) {
    fbb_.AddOffset(RuntimeOptimizationRecord::VT_NODES_TO_OPTIMIZE_INDICES, nodes_to_optimize_indices);
  }
  void add_produced_op_ids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> produced_op_ids) {
    fbb_.AddOffset(RuntimeOptimizationRecord::VT_PRODUCED_OP_IDS, produced_op_ids);
  }
  explicit RuntimeOptimizationRecordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RuntimeOptimizationRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RuntimeOptimizationRecord>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RuntimeOptimizationRecord> CreateRuntimeOptimizationRecord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> action_id = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::NodesToOptimizeIndices> nodes_to_optimize_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> produced_op_ids = 0) {
  RuntimeOptimizationRecordBuilder builder_(_fbb);
  builder_.add_produced_op_ids(produced_op_ids);
  builder_.add_nodes_to_optimize_indices(nodes_to_optimize_indices);
  builder_.add_action_id(action_id);
  return builder_.Finish();
}

struct RuntimeOptimizationRecord::Traits {
  using type = RuntimeOptimizationRecord;
  static auto constexpr Create = CreateRuntimeOptimizationRecord;
  static constexpr auto name = "RuntimeOptimizationRecord";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.RuntimeOptimizationRecord";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "action_id",
    "nodes_to_optimize_indices",
    "produced_op_ids"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<RuntimeOptimizationRecord> CreateRuntimeOptimizationRecordDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *action_id = nullptr,
    ::flatbuffers::Offset<onnxruntime::fbs::NodesToOptimizeIndices> nodes_to_optimize_indices = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *produced_op_ids = nullptr) {
  auto action_id__ = action_id ? _fbb.CreateString(action_id) : 0;
  auto produced_op_ids__ = produced_op_ids ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*produced_op_ids) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizationRecord(
      _fbb,
      action_id__,
      nodes_to_optimize_indices,
      produced_op_ids__);
}

::flatbuffers::Offset<RuntimeOptimizationRecord> CreateRuntimeOptimizationRecord(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizationRecord *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TRuntimeOptimizationRecordContainerEntry : public ::flatbuffers::NativeTable {
  typedef RuntimeOptimizationRecordContainerEntry TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TRuntimeOptimizationRecordContainerEntry";
  }
  std::string optimizer_name{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizationRecord>> runtime_optimization_records{};
  TRuntimeOptimizationRecordContainerEntry() = default;
  TRuntimeOptimizationRecordContainerEntry(const TRuntimeOptimizationRecordContainerEntry &o);
  TRuntimeOptimizationRecordContainerEntry(TRuntimeOptimizationRecordContainerEntry&&) FLATBUFFERS_NOEXCEPT = default;
  TRuntimeOptimizationRecordContainerEntry &operator=(TRuntimeOptimizationRecordContainerEntry o) FLATBUFFERS_NOEXCEPT;
};

struct RuntimeOptimizationRecordContainerEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRuntimeOptimizationRecordContainerEntry NativeTableType;
  typedef RuntimeOptimizationRecordContainerEntryBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RuntimeOptimizationRecordContainerEntryTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.RuntimeOptimizationRecordContainerEntry";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTIMIZER_NAME = 4,
    VT_RUNTIME_OPTIMIZATION_RECORDS = 6
  };
  const ::flatbuffers::String *optimizer_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPTIMIZER_NAME);
  }
  ::flatbuffers::String *mutable_optimizer_name() {
    return GetPointer<::flatbuffers::String *>(VT_OPTIMIZER_NAME);
  }
  bool KeyCompareLessThan(const RuntimeOptimizationRecordContainerEntry * const o) const {
    return *optimizer_name() < *o->optimizer_name();
  }
  int KeyCompareWithValue(const char *_optimizer_name) const {
    return strcmp(optimizer_name()->c_str(), _optimizer_name);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> *runtime_optimization_records() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> *>(VT_RUNTIME_OPTIMIZATION_RECORDS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> *mutable_runtime_optimization_records() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> *>(VT_RUNTIME_OPTIMIZATION_RECORDS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return optimizer_name();
    else if constexpr (Index == 1) return runtime_optimization_records();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OPTIMIZER_NAME) &&
           verifier.VerifyString(optimizer_name()) &&
           VerifyOffset(verifier, VT_RUNTIME_OPTIMIZATION_RECORDS) &&
           verifier.VerifyVector(runtime_optimization_records()) &&
           verifier.VerifyVectorOfTables(runtime_optimization_records()) &&
           verifier.EndTable();
  }
  TRuntimeOptimizationRecordContainerEntry *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TRuntimeOptimizationRecordContainerEntry *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizationRecordContainerEntry* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuntimeOptimizationRecordContainerEntryBuilder {
  typedef RuntimeOptimizationRecordContainerEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_optimizer_name(::flatbuffers::Offset<::flatbuffers::String> optimizer_name) {
    fbb_.AddOffset(RuntimeOptimizationRecordContainerEntry::VT_OPTIMIZER_NAME, optimizer_name);
  }
  void add_runtime_optimization_records(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>>> runtime_optimization_records) {
    fbb_.AddOffset(RuntimeOptimizationRecordContainerEntry::VT_RUNTIME_OPTIMIZATION_RECORDS, runtime_optimization_records);
  }
  explicit RuntimeOptimizationRecordContainerEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry>(end);
    fbb_.Required(o, RuntimeOptimizationRecordContainerEntry::VT_OPTIMIZER_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> CreateRuntimeOptimizationRecordContainerEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> optimizer_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>>> runtime_optimization_records = 0) {
  RuntimeOptimizationRecordContainerEntryBuilder builder_(_fbb);
  builder_.add_runtime_optimization_records(runtime_optimization_records);
  builder_.add_optimizer_name(optimizer_name);
  return builder_.Finish();
}

struct RuntimeOptimizationRecordContainerEntry::Traits {
  using type = RuntimeOptimizationRecordContainerEntry;
  static auto constexpr Create = CreateRuntimeOptimizationRecordContainerEntry;
  static constexpr auto name = "RuntimeOptimizationRecordContainerEntry";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.RuntimeOptimizationRecordContainerEntry";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "optimizer_name",
    "runtime_optimization_records"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> CreateRuntimeOptimizationRecordContainerEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *optimizer_name = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> *runtime_optimization_records = nullptr) {
  auto optimizer_name__ = optimizer_name ? _fbb.CreateString(optimizer_name) : 0;
  auto runtime_optimization_records__ = runtime_optimization_records ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>>(*runtime_optimization_records) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizationRecordContainerEntry(
      _fbb,
      optimizer_name__,
      runtime_optimization_records__);
}

::flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> CreateRuntimeOptimizationRecordContainerEntry(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizationRecordContainerEntry *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TRuntimeOptimizations : public ::flatbuffers::NativeTable {
  typedef RuntimeOptimizations TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TRuntimeOptimizations";
  }
  std::vector<std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizationRecordContainerEntry>> records{};
  TRuntimeOptimizations() = default;
  TRuntimeOptimizations(const TRuntimeOptimizations &o);
  TRuntimeOptimizations(TRuntimeOptimizations&&) FLATBUFFERS_NOEXCEPT = default;
  TRuntimeOptimizations &operator=(TRuntimeOptimizations o) FLATBUFFERS_NOEXCEPT;
};

struct RuntimeOptimizations FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRuntimeOptimizations NativeTableType;
  typedef RuntimeOptimizationsBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RuntimeOptimizationsTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.RuntimeOptimizations";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  /// mapping from optimizer name to [RuntimeOptimizationRecord]
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> *records() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> *>(VT_RECORDS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> *mutable_records() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> *>(VT_RECORDS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return records();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
  TRuntimeOptimizations *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TRuntimeOptimizations *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RuntimeOptimizations> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizations* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuntimeOptimizationsBuilder {
  typedef RuntimeOptimizations Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_records(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>>> records) {
    fbb_.AddOffset(RuntimeOptimizations::VT_RECORDS, records);
  }
  explicit RuntimeOptimizationsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RuntimeOptimizations> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RuntimeOptimizations>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RuntimeOptimizations> CreateRuntimeOptimizations(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>>> records = 0) {
  RuntimeOptimizationsBuilder builder_(_fbb);
  builder_.add_records(records);
  return builder_.Finish();
}

struct RuntimeOptimizations::Traits {
  using type = RuntimeOptimizations;
  static auto constexpr Create = CreateRuntimeOptimizations;
  static constexpr auto name = "RuntimeOptimizations";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.RuntimeOptimizations";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "records"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<RuntimeOptimizations> CreateRuntimeOptimizationsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> *records = nullptr) {
  auto records__ = records ? _fbb.CreateVectorOfSortedTables<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>(records) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizations(
      _fbb,
      records__);
}

::flatbuffers::Offset<RuntimeOptimizations> CreateRuntimeOptimizations(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizations *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TGraph : public ::flatbuffers::NativeTable {
  typedef Graph TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TGraph";
  }
  std::vector<std::unique_ptr<onnxruntime::fbs::TTensor>> initializers{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TValueInfo>> node_args{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TNode>> nodes{};
  uint32_t max_node_index = 0;
  std::vector<std::unique_ptr<onnxruntime::fbs::TNodeEdge>> node_edges{};
  std::vector<std::string> inputs{};
  std::vector<std::string> outputs{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TSparseTensor>> sparse_initializers{};
  std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizations> runtime_optimizations{};
  TGraph() = default;
  TGraph(const TGraph &o);
  TGraph(TGraph&&) FLATBUFFERS_NOEXCEPT = default;
  TGraph &operator=(TGraph o) FLATBUFFERS_NOEXCEPT;
};

struct Graph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TGraph NativeTableType;
  typedef GraphBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GraphTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.Graph";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INITIALIZERS = 4,
    VT_NODE_ARGS = 6,
    VT_NODES = 8,
    VT_MAX_NODE_INDEX = 10,
    VT_NODE_EDGES = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS = 16,
    VT_SPARSE_INITIALIZERS = 18,
    VT_RUNTIME_OPTIMIZATIONS = 20
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *initializers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *>(VT_INITIALIZERS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *mutable_initializers() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *>(VT_INITIALIZERS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> *node_args() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> *>(VT_NODE_ARGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> *mutable_node_args() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> *>(VT_NODE_ARGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Node>> *>(VT_NODES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Node>> *mutable_nodes() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Node>> *>(VT_NODES);
  }
  uint32_t max_node_index() const {
    return GetField<uint32_t>(VT_MAX_NODE_INDEX, 0);
  }
  bool mutate_max_node_index(uint32_t _max_node_index = 0) {
    return SetField<uint32_t>(VT_MAX_NODE_INDEX, _max_node_index, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> *node_edges() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> *>(VT_NODE_EDGES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> *mutable_node_edges() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> *>(VT_NODE_EDGES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_inputs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_outputs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> *sparse_initializers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> *>(VT_SPARSE_INITIALIZERS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> *mutable_sparse_initializers() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> *>(VT_SPARSE_INITIALIZERS);
  }
  const onnxruntime::fbs::RuntimeOptimizations *runtime_optimizations() const {
    return GetPointer<const onnxruntime::fbs::RuntimeOptimizations *>(VT_RUNTIME_OPTIMIZATIONS);
  }
  onnxruntime::fbs::RuntimeOptimizations *mutable_runtime_optimizations() {
    return GetPointer<onnxruntime::fbs::RuntimeOptimizations *>(VT_RUNTIME_OPTIMIZATIONS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return initializers();
    else if constexpr (Index == 1) return node_args();
    else if constexpr (Index == 2) return nodes();
    else if constexpr (Index == 3) return max_node_index();
    else if constexpr (Index == 4) return node_edges();
    else if constexpr (Index == 5) return inputs();
    else if constexpr (Index == 6) return outputs();
    else if constexpr (Index == 7) return sparse_initializers();
    else if constexpr (Index == 8) return runtime_optimizations();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INITIALIZERS) &&
           verifier.VerifyVector(initializers()) &&
           verifier.VerifyVectorOfTables(initializers()) &&
           VerifyOffset(verifier, VT_NODE_ARGS) &&
           verifier.VerifyVector(node_args()) &&
           verifier.VerifyVectorOfTables(node_args()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_NODE_INDEX, 4) &&
           VerifyOffset(verifier, VT_NODE_EDGES) &&
           verifier.VerifyVector(node_edges()) &&
           verifier.VerifyVectorOfTables(node_edges()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           VerifyOffset(verifier, VT_SPARSE_INITIALIZERS) &&
           verifier.VerifyVector(sparse_initializers()) &&
           verifier.VerifyVectorOfTables(sparse_initializers()) &&
           VerifyOffset(verifier, VT_RUNTIME_OPTIMIZATIONS) &&
           verifier.VerifyTable(runtime_optimizations()) &&
           verifier.EndTable();
  }
  TGraph *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TGraph *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Graph> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TGraph* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GraphBuilder {
  typedef Graph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_initializers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>>> initializers) {
    fbb_.AddOffset(Graph::VT_INITIALIZERS, initializers);
  }
  void add_node_args(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>>> node_args) {
    fbb_.AddOffset(Graph::VT_NODE_ARGS, node_args);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Node>>> nodes) {
    fbb_.AddOffset(Graph::VT_NODES, nodes);
  }
  void add_max_node_index(uint32_t max_node_index) {
    fbb_.AddElement<uint32_t>(Graph::VT_MAX_NODE_INDEX, max_node_index, 0);
  }
  void add_node_edges(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>>> node_edges) {
    fbb_.AddOffset(Graph::VT_NODE_EDGES, node_edges);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Graph::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Graph::VT_OUTPUTS, outputs);
  }
  void add_sparse_initializers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>>> sparse_initializers) {
    fbb_.AddOffset(Graph::VT_SPARSE_INITIALIZERS, sparse_initializers);
  }
  void add_runtime_optimizations(::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizations> runtime_optimizations) {
    fbb_.AddOffset(Graph::VT_RUNTIME_OPTIMIZATIONS, runtime_optimizations);
  }
  explicit GraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Graph> CreateGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>>> initializers = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>>> node_args = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::Node>>> nodes = 0,
    uint32_t max_node_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>>> node_edges = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>>> sparse_initializers = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizations> runtime_optimizations = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_runtime_optimizations(runtime_optimizations);
  builder_.add_sparse_initializers(sparse_initializers);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_node_edges(node_edges);
  builder_.add_max_node_index(max_node_index);
  builder_.add_nodes(nodes);
  builder_.add_node_args(node_args);
  builder_.add_initializers(initializers);
  return builder_.Finish();
}

struct Graph::Traits {
  using type = Graph;
  static auto constexpr Create = CreateGraph;
  static constexpr auto name = "Graph";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.Graph";
  static constexpr size_t fields_number = 9;
  static constexpr std::array<const char *, fields_number> field_names = {
    "initializers",
    "node_args",
    "nodes",
    "max_node_index",
    "node_edges",
    "inputs",
    "outputs",
    "sparse_initializers",
    "runtime_optimizations"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Graph> CreateGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> *initializers = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> *node_args = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::Node>> *nodes = nullptr,
    uint32_t max_node_index = 0,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> *node_edges = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> *sparse_initializers = nullptr,
    ::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizations> runtime_optimizations = 0) {
  auto initializers__ = initializers ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>>(*initializers) : 0;
  auto node_args__ = node_args ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>>(*node_args) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Node>>(*nodes) : 0;
  auto node_edges__ = node_edges ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>>(*node_edges) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputs) : 0;
  auto sparse_initializers__ = sparse_initializers ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>>(*sparse_initializers) : 0;
  return onnxruntime::fbs::CreateGraph(
      _fbb,
      initializers__,
      node_args__,
      nodes__,
      max_node_index,
      node_edges__,
      inputs__,
      outputs__,
      sparse_initializers__,
      runtime_optimizations);
}

::flatbuffers::Offset<Graph> CreateGraph(::flatbuffers::FlatBufferBuilder &_fbb, const TGraph *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TStringStringEntry : public ::flatbuffers::NativeTable {
  typedef StringStringEntry TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TStringStringEntry";
  }
  std::string key{};
  std::string value{};
};

struct StringStringEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TStringStringEntry NativeTableType;
  typedef StringStringEntryBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringStringEntryTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.StringStringEntry";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  ::flatbuffers::String *mutable_key() {
    return GetPointer<::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return key();
    else if constexpr (Index == 1) return value();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  TStringStringEntry *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TStringStringEntry *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StringStringEntry> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TStringStringEntry* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringStringEntryBuilder {
  typedef StringStringEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(StringStringEntry::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StringStringEntry::VT_VALUE, value);
  }
  explicit StringStringEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringStringEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringStringEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringStringEntry> CreateStringStringEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringStringEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct StringStringEntry::Traits {
  using type = StringStringEntry;
  static auto constexpr Create = CreateStringStringEntry;
  static constexpr auto name = "StringStringEntry";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.StringStringEntry";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "key",
    "value"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<StringStringEntry> CreateStringStringEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return onnxruntime::fbs::CreateStringStringEntry(
      _fbb,
      key__,
      value__);
}

::flatbuffers::Offset<StringStringEntry> CreateStringStringEntry(::flatbuffers::FlatBufferBuilder &_fbb, const TStringStringEntry *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TModel : public ::flatbuffers::NativeTable {
  typedef Model TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TModel";
  }
  int64_t ir_version = 0;
  std::vector<std::unique_ptr<onnxruntime::fbs::TOperatorSetId>> opset_import{};
  std::string producer_name{};
  std::string producer_version{};
  std::string domain{};
  int64_t model_version = 0;
  std::string doc_string{};
  std::unique_ptr<onnxruntime::fbs::TGraph> graph{};
  std::string graph_doc_string{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TStringStringEntry>> metadata_props{};
  TModel() = default;
  TModel(const TModel &o);
  TModel(TModel&&) FLATBUFFERS_NOEXCEPT = default;
  TModel &operator=(TModel o) FLATBUFFERS_NOEXCEPT;
};

struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TModel NativeTableType;
  typedef ModelBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModelTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.Model";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IR_VERSION = 4,
    VT_OPSET_IMPORT = 6,
    VT_PRODUCER_NAME = 8,
    VT_PRODUCER_VERSION = 10,
    VT_DOMAIN = 12,
    VT_MODEL_VERSION = 14,
    VT_DOC_STRING = 16,
    VT_GRAPH = 18,
    VT_GRAPH_DOC_STRING = 20,
    VT_METADATA_PROPS = 22
  };
  int64_t ir_version() const {
    return GetField<int64_t>(VT_IR_VERSION, 0);
  }
  bool mutate_ir_version(int64_t _ir_version = 0) {
    return SetField<int64_t>(VT_IR_VERSION, _ir_version, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> *opset_import() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> *>(VT_OPSET_IMPORT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> *mutable_opset_import() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> *>(VT_OPSET_IMPORT);
  }
  const ::flatbuffers::String *producer_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCER_NAME);
  }
  ::flatbuffers::String *mutable_producer_name() {
    return GetPointer<::flatbuffers::String *>(VT_PRODUCER_NAME);
  }
  const ::flatbuffers::String *producer_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRODUCER_VERSION);
  }
  ::flatbuffers::String *mutable_producer_version() {
    return GetPointer<::flatbuffers::String *>(VT_PRODUCER_VERSION);
  }
  const ::flatbuffers::String *domain() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOMAIN);
  }
  ::flatbuffers::String *mutable_domain() {
    return GetPointer<::flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t model_version() const {
    return GetField<int64_t>(VT_MODEL_VERSION, 0);
  }
  bool mutate_model_version(int64_t _model_version = 0) {
    return SetField<int64_t>(VT_MODEL_VERSION, _model_version, 0);
  }
  const ::flatbuffers::String *doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOC_STRING);
  }
  ::flatbuffers::String *mutable_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_DOC_STRING);
  }
  const onnxruntime::fbs::Graph *graph() const {
    return GetPointer<const onnxruntime::fbs::Graph *>(VT_GRAPH);
  }
  onnxruntime::fbs::Graph *mutable_graph() {
    return GetPointer<onnxruntime::fbs::Graph *>(VT_GRAPH);
  }
  const ::flatbuffers::String *graph_doc_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GRAPH_DOC_STRING);
  }
  ::flatbuffers::String *mutable_graph_doc_string() {
    return GetPointer<::flatbuffers::String *>(VT_GRAPH_DOC_STRING);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> *metadata_props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> *mutable_metadata_props() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ir_version();
    else if constexpr (Index == 1) return opset_import();
    else if constexpr (Index == 2) return producer_name();
    else if constexpr (Index == 3) return producer_version();
    else if constexpr (Index == 4) return domain();
    else if constexpr (Index == 5) return model_version();
    else if constexpr (Index == 6) return doc_string();
    else if constexpr (Index == 7) return graph();
    else if constexpr (Index == 8) return graph_doc_string();
    else if constexpr (Index == 9) return metadata_props();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_IR_VERSION, 8) &&
           VerifyOffset(verifier, VT_OPSET_IMPORT) &&
           verifier.VerifyVector(opset_import()) &&
           verifier.VerifyVectorOfTables(opset_import()) &&
           VerifyOffset(verifier, VT_PRODUCER_NAME) &&
           verifier.VerifyString(producer_name()) &&
           VerifyOffset(verifier, VT_PRODUCER_VERSION) &&
           verifier.VerifyString(producer_version()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_MODEL_VERSION, 8) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_GRAPH) &&
           verifier.VerifyTable(graph()) &&
           VerifyOffset(verifier, VT_GRAPH_DOC_STRING) &&
           verifier.VerifyString(graph_doc_string()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
  TModel *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TModel *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Model> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModel* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModelBuilder {
  typedef Model Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ir_version(int64_t ir_version) {
    fbb_.AddElement<int64_t>(Model::VT_IR_VERSION, ir_version, 0);
  }
  void add_opset_import(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>>> opset_import) {
    fbb_.AddOffset(Model::VT_OPSET_IMPORT, opset_import);
  }
  void add_producer_name(::flatbuffers::Offset<::flatbuffers::String> producer_name) {
    fbb_.AddOffset(Model::VT_PRODUCER_NAME, producer_name);
  }
  void add_producer_version(::flatbuffers::Offset<::flatbuffers::String> producer_version) {
    fbb_.AddOffset(Model::VT_PRODUCER_VERSION, producer_version);
  }
  void add_domain(::flatbuffers::Offset<::flatbuffers::String> domain) {
    fbb_.AddOffset(Model::VT_DOMAIN, domain);
  }
  void add_model_version(int64_t model_version) {
    fbb_.AddElement<int64_t>(Model::VT_MODEL_VERSION, model_version, 0);
  }
  void add_doc_string(::flatbuffers::Offset<::flatbuffers::String> doc_string) {
    fbb_.AddOffset(Model::VT_DOC_STRING, doc_string);
  }
  void add_graph(::flatbuffers::Offset<onnxruntime::fbs::Graph> graph) {
    fbb_.AddOffset(Model::VT_GRAPH, graph);
  }
  void add_graph_doc_string(::flatbuffers::Offset<::flatbuffers::String> graph_doc_string) {
    fbb_.AddOffset(Model::VT_GRAPH_DOC_STRING, graph_doc_string);
  }
  void add_metadata_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(Model::VT_METADATA_PROPS, metadata_props);
  }
  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Model> CreateModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>>> opset_import = 0,
    ::flatbuffers::Offset<::flatbuffers::String> producer_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> producer_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> domain = 0,
    int64_t model_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> doc_string = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::Graph> graph = 0,
    ::flatbuffers::Offset<::flatbuffers::String> graph_doc_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>>> metadata_props = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_model_version(model_version);
  builder_.add_ir_version(ir_version);
  builder_.add_metadata_props(metadata_props);
  builder_.add_graph_doc_string(graph_doc_string);
  builder_.add_graph(graph);
  builder_.add_doc_string(doc_string);
  builder_.add_domain(domain);
  builder_.add_producer_version(producer_version);
  builder_.add_producer_name(producer_name);
  builder_.add_opset_import(opset_import);
  return builder_.Finish();
}

struct Model::Traits {
  using type = Model;
  static auto constexpr Create = CreateModel;
  static constexpr auto name = "Model";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.Model";
  static constexpr size_t fields_number = 10;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ir_version",
    "opset_import",
    "producer_name",
    "producer_version",
    "domain",
    "model_version",
    "doc_string",
    "graph",
    "graph_doc_string",
    "metadata_props"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Model> CreateModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> *opset_import = nullptr,
    const char *producer_name = nullptr,
    const char *producer_version = nullptr,
    const char *domain = nullptr,
    int64_t model_version = 0,
    const char *doc_string = nullptr,
    ::flatbuffers::Offset<onnxruntime::fbs::Graph> graph = 0,
    const char *graph_doc_string = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> *metadata_props = nullptr) {
  auto opset_import__ = opset_import ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>>(*opset_import) : 0;
  auto producer_name__ = producer_name ? _fbb.CreateString(producer_name) : 0;
  auto producer_version__ = producer_version ? _fbb.CreateString(producer_version) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto graph_doc_string__ = graph_doc_string ? _fbb.CreateString(graph_doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>>(*metadata_props) : 0;
  return onnxruntime::fbs::CreateModel(
      _fbb,
      ir_version,
      opset_import__,
      producer_name__,
      producer_version__,
      domain__,
      model_version,
      doc_string__,
      graph,
      graph_doc_string__,
      metadata_props__);
}

::flatbuffers::Offset<Model> CreateModel(::flatbuffers::FlatBufferBuilder &_fbb, const TModel *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TDeprecatedKernelCreateInfos : public ::flatbuffers::NativeTable {
  typedef DeprecatedKernelCreateInfos TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TDeprecatedKernelCreateInfos";
  }
  std::vector<uint32_t> node_indices{};
  std::vector<uint64_t> kernel_def_hashes{};
};

/// deprecated: no longer using kernel def hashes
struct DeprecatedKernelCreateInfos FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDeprecatedKernelCreateInfos NativeTableType;
  typedef DeprecatedKernelCreateInfosBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeprecatedKernelCreateInfosTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.DeprecatedKernelCreateInfos";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDICES = 4,
    VT_KERNEL_DEF_HASHES = 6
  };
  const ::flatbuffers::Vector<uint32_t> *node_indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_NODE_INDICES);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_node_indices() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_NODE_INDICES);
  }
  const ::flatbuffers::Vector<uint64_t> *kernel_def_hashes() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_KERNEL_DEF_HASHES);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_kernel_def_hashes() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_KERNEL_DEF_HASHES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return node_indices();
    else if constexpr (Index == 1) return kernel_def_hashes();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_INDICES) &&
           verifier.VerifyVector(node_indices()) &&
           VerifyOffset(verifier, VT_KERNEL_DEF_HASHES) &&
           verifier.VerifyVector(kernel_def_hashes()) &&
           verifier.EndTable();
  }
  TDeprecatedKernelCreateInfos *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDeprecatedKernelCreateInfos *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeprecatedKernelCreateInfos> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedKernelCreateInfos* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeprecatedKernelCreateInfosBuilder {
  typedef DeprecatedKernelCreateInfos Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> node_indices) {
    fbb_.AddOffset(DeprecatedKernelCreateInfos::VT_NODE_INDICES, node_indices);
  }
  void add_kernel_def_hashes(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> kernel_def_hashes) {
    fbb_.AddOffset(DeprecatedKernelCreateInfos::VT_KERNEL_DEF_HASHES, kernel_def_hashes);
  }
  explicit DeprecatedKernelCreateInfosBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeprecatedKernelCreateInfos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeprecatedKernelCreateInfos>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeprecatedKernelCreateInfos> CreateDeprecatedKernelCreateInfos(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> node_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> kernel_def_hashes = 0) {
  DeprecatedKernelCreateInfosBuilder builder_(_fbb);
  builder_.add_kernel_def_hashes(kernel_def_hashes);
  builder_.add_node_indices(node_indices);
  return builder_.Finish();
}

struct DeprecatedKernelCreateInfos::Traits {
  using type = DeprecatedKernelCreateInfos;
  static auto constexpr Create = CreateDeprecatedKernelCreateInfos;
  static constexpr auto name = "DeprecatedKernelCreateInfos";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.DeprecatedKernelCreateInfos";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "node_indices",
    "kernel_def_hashes"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DeprecatedKernelCreateInfos> CreateDeprecatedKernelCreateInfosDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *node_indices = nullptr,
    const std::vector<uint64_t> *kernel_def_hashes = nullptr) {
  auto node_indices__ = node_indices ? _fbb.CreateVector<uint32_t>(*node_indices) : 0;
  auto kernel_def_hashes__ = kernel_def_hashes ? _fbb.CreateVector<uint64_t>(*kernel_def_hashes) : 0;
  return onnxruntime::fbs::CreateDeprecatedKernelCreateInfos(
      _fbb,
      node_indices__,
      kernel_def_hashes__);
}

::flatbuffers::Offset<DeprecatedKernelCreateInfos> CreateDeprecatedKernelCreateInfos(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedKernelCreateInfos *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TDeprecatedSubGraphSessionState : public ::flatbuffers::NativeTable {
  typedef DeprecatedSubGraphSessionState TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TDeprecatedSubGraphSessionState";
  }
  std::string graph_id{};
  std::unique_ptr<onnxruntime::fbs::TDeprecatedSessionState> session_state{};
  TDeprecatedSubGraphSessionState() = default;
  TDeprecatedSubGraphSessionState(const TDeprecatedSubGraphSessionState &o);
  TDeprecatedSubGraphSessionState(TDeprecatedSubGraphSessionState&&) FLATBUFFERS_NOEXCEPT = default;
  TDeprecatedSubGraphSessionState &operator=(TDeprecatedSubGraphSessionState o) FLATBUFFERS_NOEXCEPT;
};

/// deprecated: no longer using kernel def hashes
struct DeprecatedSubGraphSessionState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDeprecatedSubGraphSessionState NativeTableType;
  typedef DeprecatedSubGraphSessionStateBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeprecatedSubGraphSessionStateTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.DeprecatedSubGraphSessionState";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPH_ID = 4,
    VT_SESSION_STATE = 6
  };
  const ::flatbuffers::String *graph_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GRAPH_ID);
  }
  ::flatbuffers::String *mutable_graph_id() {
    return GetPointer<::flatbuffers::String *>(VT_GRAPH_ID);
  }
  bool KeyCompareLessThan(const DeprecatedSubGraphSessionState * const o) const {
    return *graph_id() < *o->graph_id();
  }
  int KeyCompareWithValue(const char *_graph_id) const {
    return strcmp(graph_id()->c_str(), _graph_id);
  }
  const onnxruntime::fbs::DeprecatedSessionState *session_state() const {
    return GetPointer<const onnxruntime::fbs::DeprecatedSessionState *>(VT_SESSION_STATE);
  }
  onnxruntime::fbs::DeprecatedSessionState *mutable_session_state() {
    return GetPointer<onnxruntime::fbs::DeprecatedSessionState *>(VT_SESSION_STATE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return graph_id();
    else if constexpr (Index == 1) return session_state();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPH_ID) &&
           verifier.VerifyString(graph_id()) &&
           VerifyOffset(verifier, VT_SESSION_STATE) &&
           verifier.VerifyTable(session_state()) &&
           verifier.EndTable();
  }
  TDeprecatedSubGraphSessionState *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDeprecatedSubGraphSessionState *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeprecatedSubGraphSessionState> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedSubGraphSessionState* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeprecatedSubGraphSessionStateBuilder {
  typedef DeprecatedSubGraphSessionState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_graph_id(::flatbuffers::Offset<::flatbuffers::String> graph_id) {
    fbb_.AddOffset(DeprecatedSubGraphSessionState::VT_GRAPH_ID, graph_id);
  }
  void add_session_state(::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSessionState> session_state) {
    fbb_.AddOffset(DeprecatedSubGraphSessionState::VT_SESSION_STATE, session_state);
  }
  explicit DeprecatedSubGraphSessionStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeprecatedSubGraphSessionState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeprecatedSubGraphSessionState>(end);
    fbb_.Required(o, DeprecatedSubGraphSessionState::VT_GRAPH_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<DeprecatedSubGraphSessionState> CreateDeprecatedSubGraphSessionState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> graph_id = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSessionState> session_state = 0) {
  DeprecatedSubGraphSessionStateBuilder builder_(_fbb);
  builder_.add_session_state(session_state);
  builder_.add_graph_id(graph_id);
  return builder_.Finish();
}

struct DeprecatedSubGraphSessionState::Traits {
  using type = DeprecatedSubGraphSessionState;
  static auto constexpr Create = CreateDeprecatedSubGraphSessionState;
  static constexpr auto name = "DeprecatedSubGraphSessionState";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.DeprecatedSubGraphSessionState";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "graph_id",
    "session_state"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DeprecatedSubGraphSessionState> CreateDeprecatedSubGraphSessionStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *graph_id = nullptr,
    ::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSessionState> session_state = 0) {
  auto graph_id__ = graph_id ? _fbb.CreateString(graph_id) : 0;
  return onnxruntime::fbs::CreateDeprecatedSubGraphSessionState(
      _fbb,
      graph_id__,
      session_state);
}

::flatbuffers::Offset<DeprecatedSubGraphSessionState> CreateDeprecatedSubGraphSessionState(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedSubGraphSessionState *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TDeprecatedSessionState : public ::flatbuffers::NativeTable {
  typedef DeprecatedSessionState TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TDeprecatedSessionState";
  }
  std::unique_ptr<onnxruntime::fbs::TDeprecatedKernelCreateInfos> kernels{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TDeprecatedSubGraphSessionState>> sub_graph_session_states{};
  TDeprecatedSessionState() = default;
  TDeprecatedSessionState(const TDeprecatedSessionState &o);
  TDeprecatedSessionState(TDeprecatedSessionState&&) FLATBUFFERS_NOEXCEPT = default;
  TDeprecatedSessionState &operator=(TDeprecatedSessionState o) FLATBUFFERS_NOEXCEPT;
};

/// deprecated: no longer using kernel def hashes
struct DeprecatedSessionState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDeprecatedSessionState NativeTableType;
  typedef DeprecatedSessionStateBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeprecatedSessionStateTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.DeprecatedSessionState";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNELS = 4,
    VT_SUB_GRAPH_SESSION_STATES = 6
  };
  const onnxruntime::fbs::DeprecatedKernelCreateInfos *kernels() const {
    return GetPointer<const onnxruntime::fbs::DeprecatedKernelCreateInfos *>(VT_KERNELS);
  }
  onnxruntime::fbs::DeprecatedKernelCreateInfos *mutable_kernels() {
    return GetPointer<onnxruntime::fbs::DeprecatedKernelCreateInfos *>(VT_KERNELS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> *sub_graph_session_states() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> *>(VT_SUB_GRAPH_SESSION_STATES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> *mutable_sub_graph_session_states() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> *>(VT_SUB_GRAPH_SESSION_STATES);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return kernels();
    else if constexpr (Index == 1) return sub_graph_session_states();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyTable(kernels()) &&
           VerifyOffset(verifier, VT_SUB_GRAPH_SESSION_STATES) &&
           verifier.VerifyVector(sub_graph_session_states()) &&
           verifier.VerifyVectorOfTables(sub_graph_session_states()) &&
           verifier.EndTable();
  }
  TDeprecatedSessionState *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDeprecatedSessionState *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeprecatedSessionState> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedSessionState* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeprecatedSessionStateBuilder {
  typedef DeprecatedSessionState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kernels(::flatbuffers::Offset<onnxruntime::fbs::DeprecatedKernelCreateInfos> kernels) {
    fbb_.AddOffset(DeprecatedSessionState::VT_KERNELS, kernels);
  }
  void add_sub_graph_session_states(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>>> sub_graph_session_states) {
    fbb_.AddOffset(DeprecatedSessionState::VT_SUB_GRAPH_SESSION_STATES, sub_graph_session_states);
  }
  explicit DeprecatedSessionStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeprecatedSessionState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeprecatedSessionState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeprecatedSessionState> CreateDeprecatedSessionState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::DeprecatedKernelCreateInfos> kernels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>>> sub_graph_session_states = 0) {
  DeprecatedSessionStateBuilder builder_(_fbb);
  builder_.add_sub_graph_session_states(sub_graph_session_states);
  builder_.add_kernels(kernels);
  return builder_.Finish();
}

struct DeprecatedSessionState::Traits {
  using type = DeprecatedSessionState;
  static auto constexpr Create = CreateDeprecatedSessionState;
  static constexpr auto name = "DeprecatedSessionState";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.DeprecatedSessionState";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "kernels",
    "sub_graph_session_states"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DeprecatedSessionState> CreateDeprecatedSessionStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::DeprecatedKernelCreateInfos> kernels = 0,
    std::vector<::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> *sub_graph_session_states = nullptr) {
  auto sub_graph_session_states__ = sub_graph_session_states ? _fbb.CreateVectorOfSortedTables<onnxruntime::fbs::DeprecatedSubGraphSessionState>(sub_graph_session_states) : 0;
  return onnxruntime::fbs::CreateDeprecatedSessionState(
      _fbb,
      kernels,
      sub_graph_session_states__);
}

::flatbuffers::Offset<DeprecatedSessionState> CreateDeprecatedSessionState(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedSessionState *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TArgTypeAndIndex : public ::flatbuffers::NativeTable {
  typedef ArgTypeAndIndex TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TArgTypeAndIndex";
  }
  onnxruntime::fbs::ArgType arg_type = onnxruntime::fbs::ArgType::INPUT;
  uint32_t index = 0;
};

struct ArgTypeAndIndex FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TArgTypeAndIndex NativeTableType;
  typedef ArgTypeAndIndexBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgTypeAndIndexTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.ArgTypeAndIndex";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARG_TYPE = 4,
    VT_INDEX = 6
  };
  onnxruntime::fbs::ArgType arg_type() const {
    return static_cast<onnxruntime::fbs::ArgType>(GetField<int8_t>(VT_ARG_TYPE, 0));
  }
  bool mutate_arg_type(onnxruntime::fbs::ArgType _arg_type = static_cast<onnxruntime::fbs::ArgType>(0)) {
    return SetField<int8_t>(VT_ARG_TYPE, static_cast<int8_t>(_arg_type), 0);
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool mutate_index(uint32_t _index = 0) {
    return SetField<uint32_t>(VT_INDEX, _index, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return arg_type();
    else if constexpr (Index == 1) return index();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ARG_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_INDEX, 4) &&
           verifier.EndTable();
  }
  TArgTypeAndIndex *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TArgTypeAndIndex *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ArgTypeAndIndex> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TArgTypeAndIndex* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgTypeAndIndexBuilder {
  typedef ArgTypeAndIndex Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_arg_type(onnxruntime::fbs::ArgType arg_type) {
    fbb_.AddElement<int8_t>(ArgTypeAndIndex::VT_ARG_TYPE, static_cast<int8_t>(arg_type), 0);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(ArgTypeAndIndex::VT_INDEX, index, 0);
  }
  explicit ArgTypeAndIndexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgTypeAndIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgTypeAndIndex>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgTypeAndIndex> CreateArgTypeAndIndex(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::ArgType arg_type = onnxruntime::fbs::ArgType::INPUT,
    uint32_t index = 0) {
  ArgTypeAndIndexBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_arg_type(arg_type);
  return builder_.Finish();
}

struct ArgTypeAndIndex::Traits {
  using type = ArgTypeAndIndex;
  static auto constexpr Create = CreateArgTypeAndIndex;
  static constexpr auto name = "ArgTypeAndIndex";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.ArgTypeAndIndex";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "arg_type",
    "index"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

::flatbuffers::Offset<ArgTypeAndIndex> CreateArgTypeAndIndex(::flatbuffers::FlatBufferBuilder &_fbb, const TArgTypeAndIndex *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TKernelTypeStrArgsEntry : public ::flatbuffers::NativeTable {
  typedef KernelTypeStrArgsEntry TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TKernelTypeStrArgsEntry";
  }
  std::string kernel_type_str{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TArgTypeAndIndex>> args{};
  TKernelTypeStrArgsEntry() = default;
  TKernelTypeStrArgsEntry(const TKernelTypeStrArgsEntry &o);
  TKernelTypeStrArgsEntry(TKernelTypeStrArgsEntry&&) FLATBUFFERS_NOEXCEPT = default;
  TKernelTypeStrArgsEntry &operator=(TKernelTypeStrArgsEntry o) FLATBUFFERS_NOEXCEPT;
};

struct KernelTypeStrArgsEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TKernelTypeStrArgsEntry NativeTableType;
  typedef KernelTypeStrArgsEntryBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KernelTypeStrArgsEntryTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.KernelTypeStrArgsEntry";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_TYPE_STR = 4,
    VT_ARGS = 6
  };
  const ::flatbuffers::String *kernel_type_str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KERNEL_TYPE_STR);
  }
  ::flatbuffers::String *mutable_kernel_type_str() {
    return GetPointer<::flatbuffers::String *>(VT_KERNEL_TYPE_STR);
  }
  bool KeyCompareLessThan(const KernelTypeStrArgsEntry * const o) const {
    return *kernel_type_str() < *o->kernel_type_str();
  }
  int KeyCompareWithValue(const char *_kernel_type_str) const {
    return strcmp(kernel_type_str()->c_str(), _kernel_type_str);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> *args() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> *>(VT_ARGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> *mutable_args() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> *>(VT_ARGS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return kernel_type_str();
    else if constexpr (Index == 1) return args();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KERNEL_TYPE_STR) &&
           verifier.VerifyString(kernel_type_str()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfTables(args()) &&
           verifier.EndTable();
  }
  TKernelTypeStrArgsEntry *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TKernelTypeStrArgsEntry *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<KernelTypeStrArgsEntry> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TKernelTypeStrArgsEntry* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KernelTypeStrArgsEntryBuilder {
  typedef KernelTypeStrArgsEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kernel_type_str(::flatbuffers::Offset<::flatbuffers::String> kernel_type_str) {
    fbb_.AddOffset(KernelTypeStrArgsEntry::VT_KERNEL_TYPE_STR, kernel_type_str);
  }
  void add_args(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>>> args) {
    fbb_.AddOffset(KernelTypeStrArgsEntry::VT_ARGS, args);
  }
  explicit KernelTypeStrArgsEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KernelTypeStrArgsEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KernelTypeStrArgsEntry>(end);
    fbb_.Required(o, KernelTypeStrArgsEntry::VT_KERNEL_TYPE_STR);
    return o;
  }
};

inline ::flatbuffers::Offset<KernelTypeStrArgsEntry> CreateKernelTypeStrArgsEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> kernel_type_str = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>>> args = 0) {
  KernelTypeStrArgsEntryBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_kernel_type_str(kernel_type_str);
  return builder_.Finish();
}

struct KernelTypeStrArgsEntry::Traits {
  using type = KernelTypeStrArgsEntry;
  static auto constexpr Create = CreateKernelTypeStrArgsEntry;
  static constexpr auto name = "KernelTypeStrArgsEntry";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.KernelTypeStrArgsEntry";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "kernel_type_str",
    "args"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<KernelTypeStrArgsEntry> CreateKernelTypeStrArgsEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_type_str = nullptr,
    const std::vector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> *args = nullptr) {
  auto kernel_type_str__ = kernel_type_str ? _fbb.CreateString(kernel_type_str) : 0;
  auto args__ = args ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>>(*args) : 0;
  return onnxruntime::fbs::CreateKernelTypeStrArgsEntry(
      _fbb,
      kernel_type_str__,
      args__);
}

::flatbuffers::Offset<KernelTypeStrArgsEntry> CreateKernelTypeStrArgsEntry(::flatbuffers::FlatBufferBuilder &_fbb, const TKernelTypeStrArgsEntry *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOpIdKernelTypeStrArgsEntry : public ::flatbuffers::NativeTable {
  typedef OpIdKernelTypeStrArgsEntry TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TOpIdKernelTypeStrArgsEntry";
  }
  std::string op_id{};
  std::vector<std::unique_ptr<onnxruntime::fbs::TKernelTypeStrArgsEntry>> kernel_type_str_args{};
  TOpIdKernelTypeStrArgsEntry() = default;
  TOpIdKernelTypeStrArgsEntry(const TOpIdKernelTypeStrArgsEntry &o);
  TOpIdKernelTypeStrArgsEntry(TOpIdKernelTypeStrArgsEntry&&) FLATBUFFERS_NOEXCEPT = default;
  TOpIdKernelTypeStrArgsEntry &operator=(TOpIdKernelTypeStrArgsEntry o) FLATBUFFERS_NOEXCEPT;
};

struct OpIdKernelTypeStrArgsEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TOpIdKernelTypeStrArgsEntry NativeTableType;
  typedef OpIdKernelTypeStrArgsEntryBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpIdKernelTypeStrArgsEntryTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.OpIdKernelTypeStrArgsEntry";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_KERNEL_TYPE_STR_ARGS = 6
  };
  const ::flatbuffers::String *op_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OP_ID);
  }
  ::flatbuffers::String *mutable_op_id() {
    return GetPointer<::flatbuffers::String *>(VT_OP_ID);
  }
  bool KeyCompareLessThan(const OpIdKernelTypeStrArgsEntry * const o) const {
    return *op_id() < *o->op_id();
  }
  int KeyCompareWithValue(const char *_op_id) const {
    return strcmp(op_id()->c_str(), _op_id);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> *kernel_type_str_args() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> *>(VT_KERNEL_TYPE_STR_ARGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> *mutable_kernel_type_str_args() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> *>(VT_KERNEL_TYPE_STR_ARGS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return op_id();
    else if constexpr (Index == 1) return kernel_type_str_args();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OP_ID) &&
           verifier.VerifyString(op_id()) &&
           VerifyOffset(verifier, VT_KERNEL_TYPE_STR_ARGS) &&
           verifier.VerifyVector(kernel_type_str_args()) &&
           verifier.VerifyVectorOfTables(kernel_type_str_args()) &&
           verifier.EndTable();
  }
  TOpIdKernelTypeStrArgsEntry *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOpIdKernelTypeStrArgsEntry *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TOpIdKernelTypeStrArgsEntry* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpIdKernelTypeStrArgsEntryBuilder {
  typedef OpIdKernelTypeStrArgsEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(::flatbuffers::Offset<::flatbuffers::String> op_id) {
    fbb_.AddOffset(OpIdKernelTypeStrArgsEntry::VT_OP_ID, op_id);
  }
  void add_kernel_type_str_args(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>>> kernel_type_str_args) {
    fbb_.AddOffset(OpIdKernelTypeStrArgsEntry::VT_KERNEL_TYPE_STR_ARGS, kernel_type_str_args);
  }
  explicit OpIdKernelTypeStrArgsEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OpIdKernelTypeStrArgsEntry>(end);
    fbb_.Required(o, OpIdKernelTypeStrArgsEntry::VT_OP_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> CreateOpIdKernelTypeStrArgsEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>>> kernel_type_str_args = 0) {
  OpIdKernelTypeStrArgsEntryBuilder builder_(_fbb);
  builder_.add_kernel_type_str_args(kernel_type_str_args);
  builder_.add_op_id(op_id);
  return builder_.Finish();
}

struct OpIdKernelTypeStrArgsEntry::Traits {
  using type = OpIdKernelTypeStrArgsEntry;
  static auto constexpr Create = CreateOpIdKernelTypeStrArgsEntry;
  static constexpr auto name = "OpIdKernelTypeStrArgsEntry";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.OpIdKernelTypeStrArgsEntry";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "op_id",
    "kernel_type_str_args"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> CreateOpIdKernelTypeStrArgsEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *op_id = nullptr,
    std::vector<::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> *kernel_type_str_args = nullptr) {
  auto op_id__ = op_id ? _fbb.CreateString(op_id) : 0;
  auto kernel_type_str_args__ = kernel_type_str_args ? _fbb.CreateVectorOfSortedTables<onnxruntime::fbs::KernelTypeStrArgsEntry>(kernel_type_str_args) : 0;
  return onnxruntime::fbs::CreateOpIdKernelTypeStrArgsEntry(
      _fbb,
      op_id__,
      kernel_type_str_args__);
}

::flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> CreateOpIdKernelTypeStrArgsEntry(::flatbuffers::FlatBufferBuilder &_fbb, const TOpIdKernelTypeStrArgsEntry *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TKernelTypeStrResolver : public ::flatbuffers::NativeTable {
  typedef KernelTypeStrResolver TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TKernelTypeStrResolver";
  }
  std::vector<std::unique_ptr<onnxruntime::fbs::TOpIdKernelTypeStrArgsEntry>> op_kernel_type_str_args{};
  TKernelTypeStrResolver() = default;
  TKernelTypeStrResolver(const TKernelTypeStrResolver &o);
  TKernelTypeStrResolver(TKernelTypeStrResolver&&) FLATBUFFERS_NOEXCEPT = default;
  TKernelTypeStrResolver &operator=(TKernelTypeStrResolver o) FLATBUFFERS_NOEXCEPT;
};

struct KernelTypeStrResolver FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TKernelTypeStrResolver NativeTableType;
  typedef KernelTypeStrResolverBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KernelTypeStrResolverTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.KernelTypeStrResolver";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_KERNEL_TYPE_STR_ARGS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> *op_kernel_type_str_args() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> *>(VT_OP_KERNEL_TYPE_STR_ARGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> *mutable_op_kernel_type_str_args() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> *>(VT_OP_KERNEL_TYPE_STR_ARGS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return op_kernel_type_str_args();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OP_KERNEL_TYPE_STR_ARGS) &&
           verifier.VerifyVector(op_kernel_type_str_args()) &&
           verifier.VerifyVectorOfTables(op_kernel_type_str_args()) &&
           verifier.EndTable();
  }
  TKernelTypeStrResolver *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TKernelTypeStrResolver *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<KernelTypeStrResolver> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TKernelTypeStrResolver* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KernelTypeStrResolverBuilder {
  typedef KernelTypeStrResolver Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_kernel_type_str_args(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>>> op_kernel_type_str_args) {
    fbb_.AddOffset(KernelTypeStrResolver::VT_OP_KERNEL_TYPE_STR_ARGS, op_kernel_type_str_args);
  }
  explicit KernelTypeStrResolverBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KernelTypeStrResolver> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KernelTypeStrResolver>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KernelTypeStrResolver> CreateKernelTypeStrResolver(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>>> op_kernel_type_str_args = 0) {
  KernelTypeStrResolverBuilder builder_(_fbb);
  builder_.add_op_kernel_type_str_args(op_kernel_type_str_args);
  return builder_.Finish();
}

struct KernelTypeStrResolver::Traits {
  using type = KernelTypeStrResolver;
  static auto constexpr Create = CreateKernelTypeStrResolver;
  static constexpr auto name = "KernelTypeStrResolver";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.KernelTypeStrResolver";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "op_kernel_type_str_args"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<KernelTypeStrResolver> CreateKernelTypeStrResolverDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<::flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> *op_kernel_type_str_args = nullptr) {
  auto op_kernel_type_str_args__ = op_kernel_type_str_args ? _fbb.CreateVectorOfSortedTables<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>(op_kernel_type_str_args) : 0;
  return onnxruntime::fbs::CreateKernelTypeStrResolver(
      _fbb,
      op_kernel_type_str_args__);
}

::flatbuffers::Offset<KernelTypeStrResolver> CreateKernelTypeStrResolver(::flatbuffers::FlatBufferBuilder &_fbb, const TKernelTypeStrResolver *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TInferenceSession : public ::flatbuffers::NativeTable {
  typedef InferenceSession TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.TInferenceSession";
  }
  std::string ort_version{};
  std::unique_ptr<onnxruntime::fbs::TModel> model{};
  std::unique_ptr<onnxruntime::fbs::TKernelTypeStrResolver> kernel_type_str_resolver{};
  TInferenceSession() = default;
  TInferenceSession(const TInferenceSession &o);
  TInferenceSession(TInferenceSession&&) FLATBUFFERS_NOEXCEPT = default;
  TInferenceSession &operator=(TInferenceSession o) FLATBUFFERS_NOEXCEPT;
};

struct InferenceSession FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TInferenceSession NativeTableType;
  typedef InferenceSessionBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InferenceSessionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "onnxruntime.fbs.InferenceSession";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORT_VERSION = 4,
    VT_MODEL = 6,
    VT_KERNEL_TYPE_STR_RESOLVER = 10
  };
  const ::flatbuffers::String *ort_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORT_VERSION);
  }
  ::flatbuffers::String *mutable_ort_version() {
    return GetPointer<::flatbuffers::String *>(VT_ORT_VERSION);
  }
  const onnxruntime::fbs::Model *model() const {
    return GetPointer<const onnxruntime::fbs::Model *>(VT_MODEL);
  }
  onnxruntime::fbs::Model *mutable_model() {
    return GetPointer<onnxruntime::fbs::Model *>(VT_MODEL);
  }
  const onnxruntime::fbs::KernelTypeStrResolver *kernel_type_str_resolver() const {
    return GetPointer<const onnxruntime::fbs::KernelTypeStrResolver *>(VT_KERNEL_TYPE_STR_RESOLVER);
  }
  onnxruntime::fbs::KernelTypeStrResolver *mutable_kernel_type_str_resolver() {
    return GetPointer<onnxruntime::fbs::KernelTypeStrResolver *>(VT_KERNEL_TYPE_STR_RESOLVER);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return ort_version();
    else if constexpr (Index == 1) return model();
    else if constexpr (Index == 2) return kernel_type_str_resolver();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORT_VERSION) &&
           verifier.VerifyString(ort_version()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyTable(model()) &&
           VerifyOffset(verifier, VT_KERNEL_TYPE_STR_RESOLVER) &&
           verifier.VerifyTable(kernel_type_str_resolver()) &&
           verifier.EndTable();
  }
  TInferenceSession *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TInferenceSession *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<InferenceSession> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TInferenceSession* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InferenceSessionBuilder {
  typedef InferenceSession Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ort_version(::flatbuffers::Offset<::flatbuffers::String> ort_version) {
    fbb_.AddOffset(InferenceSession::VT_ORT_VERSION, ort_version);
  }
  void add_model(::flatbuffers::Offset<onnxruntime::fbs::Model> model) {
    fbb_.AddOffset(InferenceSession::VT_MODEL, model);
  }
  void add_kernel_type_str_resolver(::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrResolver> kernel_type_str_resolver) {
    fbb_.AddOffset(InferenceSession::VT_KERNEL_TYPE_STR_RESOLVER, kernel_type_str_resolver);
  }
  explicit InferenceSessionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InferenceSession> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InferenceSession>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InferenceSession> CreateInferenceSession(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ort_version = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::Model> model = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrResolver> kernel_type_str_resolver = 0) {
  InferenceSessionBuilder builder_(_fbb);
  builder_.add_kernel_type_str_resolver(kernel_type_str_resolver);
  builder_.add_model(model);
  builder_.add_ort_version(ort_version);
  return builder_.Finish();
}

struct InferenceSession::Traits {
  using type = InferenceSession;
  static auto constexpr Create = CreateInferenceSession;
  static constexpr auto name = "InferenceSession";
  static constexpr auto fully_qualified_name = "onnxruntime.fbs.InferenceSession";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "ort_version",
    "model",
    "kernel_type_str_resolver"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<InferenceSession> CreateInferenceSessionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ort_version = nullptr,
    ::flatbuffers::Offset<onnxruntime::fbs::Model> model = 0,
    ::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrResolver> kernel_type_str_resolver = 0) {
  auto ort_version__ = ort_version ? _fbb.CreateString(ort_version) : 0;
  return onnxruntime::fbs::CreateInferenceSession(
      _fbb,
      ort_version__,
      model,
      kernel_type_str_resolver);
}

::flatbuffers::Offset<InferenceSession> CreateInferenceSession(::flatbuffers::FlatBufferBuilder &_fbb, const TInferenceSession *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const TShape &lhs, const TShape &rhs) {
  return
      (lhs.dim.size() == rhs.dim.size() && std::equal(lhs.dim.cbegin(), lhs.dim.cend(), rhs.dim.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TDimension> const &a, std::unique_ptr<onnxruntime::fbs::TDimension> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TShape &lhs, const TShape &rhs) {
    return !(lhs == rhs);
}


inline TShape::TShape(const TShape &o) {
  dim.reserve(o.dim.size());
  for (const auto &dim_ : o.dim) { dim.emplace_back((dim_) ? new onnxruntime::fbs::TDimension(*dim_) : nullptr); }
}

inline TShape &TShape::operator=(TShape o) FLATBUFFERS_NOEXCEPT {
  std::swap(dim, o.dim);
  return *this;
}

inline TShape *Shape::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TShape>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Shape::UnPackTo(TShape *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dim(); if (_e) { _o->dim.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->dim[_i]) { _e->Get(_i)->UnPackTo(_o->dim[_i].get(), _resolver); } else { _o->dim[_i] = std::unique_ptr<onnxruntime::fbs::TDimension>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->dim.resize(0); } }
}

inline ::flatbuffers::Offset<Shape> Shape::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TShape* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShape(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Shape> CreateShape(::flatbuffers::FlatBufferBuilder &_fbb, const TShape *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TShape* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dim = _o->dim.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Dimension>> (_o->dim.size(), [](size_t i, _VectorArgs *__va) { return CreateDimension(*__va->__fbb, __va->__o->dim[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateShape(
      _fbb,
      _dim);
}


inline bool operator==(const TDimension &lhs, const TDimension &rhs) {
  return
      ((lhs.value == rhs.value) || (lhs.value && rhs.value && *lhs.value == *rhs.value)) &&
      (lhs.denotation == rhs.denotation);
}

inline bool operator!=(const TDimension &lhs, const TDimension &rhs) {
    return !(lhs == rhs);
}


inline TDimension::TDimension(const TDimension &o)
      : value((o.value) ? new onnxruntime::fbs::TDimensionValue(*o.value) : nullptr),
        denotation(o.denotation) {
}

inline TDimension &TDimension::operator=(TDimension o) FLATBUFFERS_NOEXCEPT {
  std::swap(value, o.value);
  std::swap(denotation, o.denotation);
  return *this;
}

inline TDimension *Dimension::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TDimension>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Dimension::UnPackTo(TDimension *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) { if(_o->value) { _e->UnPackTo(_o->value.get(), _resolver); } else { _o->value = std::unique_ptr<onnxruntime::fbs::TDimensionValue>(_e->UnPack(_resolver)); } } else if (_o->value) { _o->value.reset(); } }
  { auto _e = denotation(); if (_e) _o->denotation = _e->str(); }
}

inline ::flatbuffers::Offset<Dimension> Dimension::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDimension* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDimension(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Dimension> CreateDimension(::flatbuffers::FlatBufferBuilder &_fbb, const TDimension *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDimension* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value ? CreateDimensionValue(_fbb, _o->value.get(), _rehasher) : 0;
  auto _denotation = _o->denotation.empty() ? 0 : _fbb.CreateString(_o->denotation);
  return onnxruntime::fbs::CreateDimension(
      _fbb,
      _value,
      _denotation);
}


inline bool operator==(const TDimensionValue &lhs, const TDimensionValue &rhs) {
  return
      (lhs.dim_type == rhs.dim_type) &&
      (lhs.dim_value == rhs.dim_value) &&
      (lhs.dim_param == rhs.dim_param);
}

inline bool operator!=(const TDimensionValue &lhs, const TDimensionValue &rhs) {
    return !(lhs == rhs);
}


inline TDimensionValue *DimensionValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TDimensionValue>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DimensionValue::UnPackTo(TDimensionValue *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dim_type(); _o->dim_type = _e; }
  { auto _e = dim_value(); _o->dim_value = _e; }
  { auto _e = dim_param(); if (_e) _o->dim_param = _e->str(); }
}

inline ::flatbuffers::Offset<DimensionValue> DimensionValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDimensionValue* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDimensionValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DimensionValue> CreateDimensionValue(::flatbuffers::FlatBufferBuilder &_fbb, const TDimensionValue *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDimensionValue* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dim_type = _o->dim_type;
  auto _dim_value = _o->dim_value;
  auto _dim_param = _o->dim_param.empty() ? 0 : _fbb.CreateString(_o->dim_param);
  return onnxruntime::fbs::CreateDimensionValue(
      _fbb,
      _dim_type,
      _dim_value,
      _dim_param);
}


inline bool operator==(const TTensorTypeAndShape &lhs, const TTensorTypeAndShape &rhs) {
  return
      (lhs.elem_type == rhs.elem_type) &&
      ((lhs.shape == rhs.shape) || (lhs.shape && rhs.shape && *lhs.shape == *rhs.shape));
}

inline bool operator!=(const TTensorTypeAndShape &lhs, const TTensorTypeAndShape &rhs) {
    return !(lhs == rhs);
}


inline TTensorTypeAndShape::TTensorTypeAndShape(const TTensorTypeAndShape &o)
      : elem_type(o.elem_type),
        shape((o.shape) ? new onnxruntime::fbs::TShape(*o.shape) : nullptr) {
}

inline TTensorTypeAndShape &TTensorTypeAndShape::operator=(TTensorTypeAndShape o) FLATBUFFERS_NOEXCEPT {
  std::swap(elem_type, o.elem_type);
  std::swap(shape, o.shape);
  return *this;
}

inline TTensorTypeAndShape *TensorTypeAndShape::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TTensorTypeAndShape>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorTypeAndShape::UnPackTo(TTensorTypeAndShape *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = elem_type(); _o->elem_type = _e; }
  { auto _e = shape(); if (_e) { if(_o->shape) { _e->UnPackTo(_o->shape.get(), _resolver); } else { _o->shape = std::unique_ptr<onnxruntime::fbs::TShape>(_e->UnPack(_resolver)); } } else if (_o->shape) { _o->shape.reset(); } }
}

inline ::flatbuffers::Offset<TensorTypeAndShape> TensorTypeAndShape::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTensorTypeAndShape* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorTypeAndShape(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TensorTypeAndShape> CreateTensorTypeAndShape(::flatbuffers::FlatBufferBuilder &_fbb, const TTensorTypeAndShape *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TTensorTypeAndShape* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _elem_type = _o->elem_type;
  auto _shape = _o->shape ? CreateShape(_fbb, _o->shape.get(), _rehasher) : 0;
  return onnxruntime::fbs::CreateTensorTypeAndShape(
      _fbb,
      _elem_type,
      _shape);
}


inline bool operator==(const TMapType &lhs, const TMapType &rhs) {
  return
      (lhs.key_type == rhs.key_type) &&
      ((lhs.value_type == rhs.value_type) || (lhs.value_type && rhs.value_type && *lhs.value_type == *rhs.value_type));
}

inline bool operator!=(const TMapType &lhs, const TMapType &rhs) {
    return !(lhs == rhs);
}


inline TMapType::TMapType(const TMapType &o)
      : key_type(o.key_type),
        value_type((o.value_type) ? new onnxruntime::fbs::TTypeInfo(*o.value_type) : nullptr) {
}

inline TMapType &TMapType::operator=(TMapType o) FLATBUFFERS_NOEXCEPT {
  std::swap(key_type, o.key_type);
  std::swap(value_type, o.value_type);
  return *this;
}

inline TMapType *MapType::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TMapType>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapType::UnPackTo(TMapType *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key_type(); _o->key_type = _e; }
  { auto _e = value_type(); if (_e) { if(_o->value_type) { _e->UnPackTo(_o->value_type.get(), _resolver); } else { _o->value_type = std::unique_ptr<onnxruntime::fbs::TTypeInfo>(_e->UnPack(_resolver)); } } else if (_o->value_type) { _o->value_type.reset(); } }
}

inline ::flatbuffers::Offset<MapType> MapType::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TMapType* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapType(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MapType> CreateMapType(::flatbuffers::FlatBufferBuilder &_fbb, const TMapType *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TMapType* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key_type = _o->key_type;
  auto _value_type = _o->value_type ? CreateTypeInfo(_fbb, _o->value_type.get(), _rehasher) : 0;
  return onnxruntime::fbs::CreateMapType(
      _fbb,
      _key_type,
      _value_type);
}


inline bool operator==(const TSequenceType &lhs, const TSequenceType &rhs) {
  return
      ((lhs.elem_type == rhs.elem_type) || (lhs.elem_type && rhs.elem_type && *lhs.elem_type == *rhs.elem_type));
}

inline bool operator!=(const TSequenceType &lhs, const TSequenceType &rhs) {
    return !(lhs == rhs);
}


inline TSequenceType::TSequenceType(const TSequenceType &o)
      : elem_type((o.elem_type) ? new onnxruntime::fbs::TTypeInfo(*o.elem_type) : nullptr) {
}

inline TSequenceType &TSequenceType::operator=(TSequenceType o) FLATBUFFERS_NOEXCEPT {
  std::swap(elem_type, o.elem_type);
  return *this;
}

inline TSequenceType *SequenceType::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TSequenceType>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SequenceType::UnPackTo(TSequenceType *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = elem_type(); if (_e) { if(_o->elem_type) { _e->UnPackTo(_o->elem_type.get(), _resolver); } else { _o->elem_type = std::unique_ptr<onnxruntime::fbs::TTypeInfo>(_e->UnPack(_resolver)); } } else if (_o->elem_type) { _o->elem_type.reset(); } }
}

inline ::flatbuffers::Offset<SequenceType> SequenceType::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TSequenceType* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSequenceType(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SequenceType> CreateSequenceType(::flatbuffers::FlatBufferBuilder &_fbb, const TSequenceType *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TSequenceType* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _elem_type = _o->elem_type ? CreateTypeInfo(_fbb, _o->elem_type.get(), _rehasher) : 0;
  return onnxruntime::fbs::CreateSequenceType(
      _fbb,
      _elem_type);
}


inline bool operator==(const TNodeEdge &lhs, const TNodeEdge &rhs) {
  return
      (lhs.node_index == rhs.node_index) &&
      (lhs.input_edges == rhs.input_edges) &&
      (lhs.output_edges == rhs.output_edges);
}

inline bool operator!=(const TNodeEdge &lhs, const TNodeEdge &rhs) {
    return !(lhs == rhs);
}


inline TNodeEdge *NodeEdge::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TNodeEdge>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NodeEdge::UnPackTo(TNodeEdge *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = node_index(); _o->node_index = _e; }
  { auto _e = input_edges(); if (_e) { _o->input_edges.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_edges[_i] = *_e->Get(_i); } } else { _o->input_edges.resize(0); } }
  { auto _e = output_edges(); if (_e) { _o->output_edges.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_edges[_i] = *_e->Get(_i); } } else { _o->output_edges.resize(0); } }
}

inline ::flatbuffers::Offset<NodeEdge> NodeEdge::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TNodeEdge* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNodeEdge(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NodeEdge> CreateNodeEdge(::flatbuffers::FlatBufferBuilder &_fbb, const TNodeEdge *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TNodeEdge* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _node_index = _o->node_index;
  auto _input_edges = _o->input_edges.size() ? _fbb.CreateVectorOfStructs(_o->input_edges) : 0;
  auto _output_edges = _o->output_edges.size() ? _fbb.CreateVectorOfStructs(_o->output_edges) : 0;
  return onnxruntime::fbs::CreateNodeEdge(
      _fbb,
      _node_index,
      _input_edges,
      _output_edges);
}


inline bool operator==(const TNode &lhs, const TNode &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.doc_string == rhs.doc_string) &&
      (lhs.domain == rhs.domain) &&
      (lhs.since_version == rhs.since_version) &&
      (lhs.index == rhs.index) &&
      (lhs.op_type == rhs.op_type) &&
      (lhs.type == rhs.type) &&
      (lhs.execution_provider_type == rhs.execution_provider_type) &&
      (lhs.inputs == rhs.inputs) &&
      (lhs.outputs == rhs.outputs) &&
      (lhs.attributes.size() == rhs.attributes.size() && std::equal(lhs.attributes.cbegin(), lhs.attributes.cend(), rhs.attributes.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TAttribute> const &a, std::unique_ptr<onnxruntime::fbs::TAttribute> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.input_arg_counts == rhs.input_arg_counts) &&
      (lhs.implicit_inputs == rhs.implicit_inputs);
}

inline bool operator!=(const TNode &lhs, const TNode &rhs) {
    return !(lhs == rhs);
}


inline TNode::TNode(const TNode &o)
      : name(o.name),
        doc_string(o.doc_string),
        domain(o.domain),
        since_version(o.since_version),
        index(o.index),
        op_type(o.op_type),
        type(o.type),
        execution_provider_type(o.execution_provider_type),
        inputs(o.inputs),
        outputs(o.outputs),
        input_arg_counts(o.input_arg_counts),
        implicit_inputs(o.implicit_inputs) {
  attributes.reserve(o.attributes.size());
  for (const auto &attributes_ : o.attributes) { attributes.emplace_back((attributes_) ? new onnxruntime::fbs::TAttribute(*attributes_) : nullptr); }
}

inline TNode &TNode::operator=(TNode o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(doc_string, o.doc_string);
  std::swap(domain, o.domain);
  std::swap(since_version, o.since_version);
  std::swap(index, o.index);
  std::swap(op_type, o.op_type);
  std::swap(type, o.type);
  std::swap(execution_provider_type, o.execution_provider_type);
  std::swap(inputs, o.inputs);
  std::swap(outputs, o.outputs);
  std::swap(attributes, o.attributes);
  std::swap(input_arg_counts, o.input_arg_counts);
  std::swap(implicit_inputs, o.implicit_inputs);
  return *this;
}

inline TNode *Node::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TNode>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Node::UnPackTo(TNode *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = doc_string(); if (_e) _o->doc_string = _e->str(); }
  { auto _e = domain(); if (_e) _o->domain = _e->str(); }
  { auto _e = since_version(); _o->since_version = _e; }
  { auto _e = index(); _o->index = _e; }
  { auto _e = op_type(); if (_e) _o->op_type = _e->str(); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = execution_provider_type(); if (_e) _o->execution_provider_type = _e->str(); }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i)->str(); } } else { _o->inputs.resize(0); } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i)->str(); } } else { _o->outputs.resize(0); } }
  { auto _e = attributes(); if (_e) { _o->attributes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->attributes[_i]) { _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver); } else { _o->attributes[_i] = std::unique_ptr<onnxruntime::fbs::TAttribute>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->attributes.resize(0); } }
  { auto _e = input_arg_counts(); if (_e) { _o->input_arg_counts.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_arg_counts[_i] = _e->Get(_i); } } else { _o->input_arg_counts.resize(0); } }
  { auto _e = implicit_inputs(); if (_e) { _o->implicit_inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->implicit_inputs[_i] = _e->Get(_i)->str(); } } else { _o->implicit_inputs.resize(0); } }
}

inline ::flatbuffers::Offset<Node> Node::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TNode* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const TNode *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TNode* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _doc_string = _o->doc_string.empty() ? 0 : _fbb.CreateString(_o->doc_string);
  auto _domain = _o->domain.empty() ? 0 : _fbb.CreateString(_o->domain);
  auto _since_version = _o->since_version;
  auto _index = _o->index;
  auto _op_type = _o->op_type.empty() ? 0 : _fbb.CreateString(_o->op_type);
  auto _type = _o->type;
  auto _execution_provider_type = _o->execution_provider_type.empty() ? 0 : _fbb.CreateString(_o->execution_provider_type);
  auto _inputs = _o->inputs.size() ? _fbb.CreateVectorOfStrings(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVectorOfStrings(_o->outputs) : 0;
  auto _attributes = _o->attributes.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Attribute>> (_o->attributes.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _input_arg_counts = _o->input_arg_counts.size() ? _fbb.CreateVector(_o->input_arg_counts) : 0;
  auto _implicit_inputs = _o->implicit_inputs.size() ? _fbb.CreateVectorOfStrings(_o->implicit_inputs) : 0;
  return onnxruntime::fbs::CreateNode(
      _fbb,
      _name,
      _doc_string,
      _domain,
      _since_version,
      _index,
      _op_type,
      _type,
      _execution_provider_type,
      _inputs,
      _outputs,
      _attributes,
      _input_arg_counts,
      _implicit_inputs);
}


inline bool operator==(const TValueInfo &lhs, const TValueInfo &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.doc_string == rhs.doc_string) &&
      ((lhs.type == rhs.type) || (lhs.type && rhs.type && *lhs.type == *rhs.type));
}

inline bool operator!=(const TValueInfo &lhs, const TValueInfo &rhs) {
    return !(lhs == rhs);
}


inline TValueInfo::TValueInfo(const TValueInfo &o)
      : name(o.name),
        doc_string(o.doc_string),
        type((o.type) ? new onnxruntime::fbs::TTypeInfo(*o.type) : nullptr) {
}

inline TValueInfo &TValueInfo::operator=(TValueInfo o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(doc_string, o.doc_string);
  std::swap(type, o.type);
  return *this;
}

inline TValueInfo *ValueInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TValueInfo>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ValueInfo::UnPackTo(TValueInfo *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = doc_string(); if (_e) _o->doc_string = _e->str(); }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<onnxruntime::fbs::TTypeInfo>(_e->UnPack(_resolver)); } } else if (_o->type) { _o->type.reset(); } }
}

inline ::flatbuffers::Offset<ValueInfo> ValueInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TValueInfo* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValueInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ValueInfo> CreateValueInfo(::flatbuffers::FlatBufferBuilder &_fbb, const TValueInfo *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TValueInfo* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _doc_string = _o->doc_string.empty() ? 0 : _fbb.CreateString(_o->doc_string);
  auto _type = _o->type ? CreateTypeInfo(_fbb, _o->type.get(), _rehasher) : 0;
  return onnxruntime::fbs::CreateValueInfo(
      _fbb,
      _name,
      _doc_string,
      _type);
}


inline bool operator==(const TTypeInfo &lhs, const TTypeInfo &rhs) {
  return
      (lhs.denotation == rhs.denotation) &&
      (lhs.value == rhs.value);
}

inline bool operator!=(const TTypeInfo &lhs, const TTypeInfo &rhs) {
    return !(lhs == rhs);
}


inline TTypeInfo *TypeInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TTypeInfo>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeInfo::UnPackTo(TTypeInfo *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = denotation(); if (_e) _o->denotation = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = onnxruntime::fbs::TypeInfoValueUnion::UnPack(_e, value_type(), _resolver); }
}

inline ::flatbuffers::Offset<TypeInfo> TypeInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTypeInfo* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TypeInfo> CreateTypeInfo(::flatbuffers::FlatBufferBuilder &_fbb, const TTypeInfo *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TTypeInfo* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _denotation = _o->denotation.empty() ? 0 : _fbb.CreateString(_o->denotation);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return onnxruntime::fbs::CreateTypeInfo(
      _fbb,
      _denotation,
      _value_type,
      _value);
}


inline bool operator==(const TOperatorSetId &lhs, const TOperatorSetId &rhs) {
  return
      (lhs.domain == rhs.domain) &&
      (lhs.version == rhs.version);
}

inline bool operator!=(const TOperatorSetId &lhs, const TOperatorSetId &rhs) {
    return !(lhs == rhs);
}


inline TOperatorSetId *OperatorSetId::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TOperatorSetId>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorSetId::UnPackTo(TOperatorSetId *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = domain(); if (_e) _o->domain = _e->str(); }
  { auto _e = version(); _o->version = _e; }
}

inline ::flatbuffers::Offset<OperatorSetId> OperatorSetId::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TOperatorSetId* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorSetId(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OperatorSetId> CreateOperatorSetId(::flatbuffers::FlatBufferBuilder &_fbb, const TOperatorSetId *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TOperatorSetId* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _domain = _o->domain.empty() ? 0 : _fbb.CreateString(_o->domain);
  auto _version = _o->version;
  return onnxruntime::fbs::CreateOperatorSetId(
      _fbb,
      _domain,
      _version);
}


inline bool operator==(const TTensor &lhs, const TTensor &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.doc_string == rhs.doc_string) &&
      (lhs.dims == rhs.dims) &&
      (lhs.data_type == rhs.data_type) &&
      (lhs.raw_data == rhs.raw_data) &&
      (lhs.string_data == rhs.string_data);
}

inline bool operator!=(const TTensor &lhs, const TTensor &rhs) {
    return !(lhs == rhs);
}


inline TTensor *Tensor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TTensor>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tensor::UnPackTo(TTensor *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = doc_string(); if (_e) _o->doc_string = _e->str(); }
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } else { _o->dims.resize(0); } }
  { auto _e = data_type(); _o->data_type = _e; }
  { auto _e = raw_data(); if (_e) { _o->raw_data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->raw_data.begin()); } }
  { auto _e = string_data(); if (_e) { _o->string_data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->string_data[_i] = _e->Get(_i)->str(); } } else { _o->string_data.resize(0); } }
}

inline ::flatbuffers::Offset<Tensor> Tensor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTensor* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Tensor> CreateTensor(::flatbuffers::FlatBufferBuilder &_fbb, const TTensor *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TTensor* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _doc_string = _o->doc_string.empty() ? 0 : _fbb.CreateString(_o->doc_string);
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _data_type = _o->data_type;
  auto _raw_data = _o->raw_data.size() ? _fbb.CreateVector(_o->raw_data) : 0;
  auto _string_data = _o->string_data.size() ? _fbb.CreateVectorOfStrings(_o->string_data) : 0;
  return onnxruntime::fbs::CreateTensor(
      _fbb,
      _name,
      _doc_string,
      _dims,
      _data_type,
      _raw_data,
      _string_data);
}


inline bool operator==(const TSparseTensor &lhs, const TSparseTensor &rhs) {
  return
      ((lhs.values == rhs.values) || (lhs.values && rhs.values && *lhs.values == *rhs.values)) &&
      ((lhs.indices == rhs.indices) || (lhs.indices && rhs.indices && *lhs.indices == *rhs.indices)) &&
      (lhs.dims == rhs.dims);
}

inline bool operator!=(const TSparseTensor &lhs, const TSparseTensor &rhs) {
    return !(lhs == rhs);
}


inline TSparseTensor::TSparseTensor(const TSparseTensor &o)
      : values((o.values) ? new onnxruntime::fbs::TTensor(*o.values) : nullptr),
        indices((o.indices) ? new onnxruntime::fbs::TTensor(*o.indices) : nullptr),
        dims(o.dims) {
}

inline TSparseTensor &TSparseTensor::operator=(TSparseTensor o) FLATBUFFERS_NOEXCEPT {
  std::swap(values, o.values);
  std::swap(indices, o.indices);
  std::swap(dims, o.dims);
  return *this;
}

inline TSparseTensor *SparseTensor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TSparseTensor>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseTensor::UnPackTo(TSparseTensor *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { if(_o->values) { _e->UnPackTo(_o->values.get(), _resolver); } else { _o->values = std::unique_ptr<onnxruntime::fbs::TTensor>(_e->UnPack(_resolver)); } } else if (_o->values) { _o->values.reset(); } }
  { auto _e = indices(); if (_e) { if(_o->indices) { _e->UnPackTo(_o->indices.get(), _resolver); } else { _o->indices = std::unique_ptr<onnxruntime::fbs::TTensor>(_e->UnPack(_resolver)); } } else if (_o->indices) { _o->indices.reset(); } }
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } else { _o->dims.resize(0); } }
}

inline ::flatbuffers::Offset<SparseTensor> SparseTensor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TSparseTensor* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseTensor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SparseTensor> CreateSparseTensor(::flatbuffers::FlatBufferBuilder &_fbb, const TSparseTensor *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TSparseTensor* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _o->values ? CreateTensor(_fbb, _o->values.get(), _rehasher) : 0;
  auto _indices = _o->indices ? CreateTensor(_fbb, _o->indices.get(), _rehasher) : 0;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return onnxruntime::fbs::CreateSparseTensor(
      _fbb,
      _values,
      _indices,
      _dims);
}


inline bool operator==(const TAttribute &lhs, const TAttribute &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.doc_string == rhs.doc_string) &&
      (lhs.type == rhs.type) &&
      (lhs.f == rhs.f) &&
      (lhs.i == rhs.i) &&
      (lhs.s == rhs.s) &&
      ((lhs.t == rhs.t) || (lhs.t && rhs.t && *lhs.t == *rhs.t)) &&
      ((lhs.g == rhs.g) || (lhs.g && rhs.g && *lhs.g == *rhs.g)) &&
      (lhs.floats == rhs.floats) &&
      (lhs.ints == rhs.ints) &&
      (lhs.strings == rhs.strings) &&
      (lhs.tensors.size() == rhs.tensors.size() && std::equal(lhs.tensors.cbegin(), lhs.tensors.cend(), rhs.tensors.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TTensor> const &a, std::unique_ptr<onnxruntime::fbs::TTensor> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.graphs.size() == rhs.graphs.size() && std::equal(lhs.graphs.cbegin(), lhs.graphs.cend(), rhs.graphs.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TGraph> const &a, std::unique_ptr<onnxruntime::fbs::TGraph> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TAttribute &lhs, const TAttribute &rhs) {
    return !(lhs == rhs);
}


inline TAttribute::TAttribute(const TAttribute &o)
      : name(o.name),
        doc_string(o.doc_string),
        type(o.type),
        f(o.f),
        i(o.i),
        s(o.s),
        t((o.t) ? new onnxruntime::fbs::TTensor(*o.t) : nullptr),
        g((o.g) ? new onnxruntime::fbs::TGraph(*o.g) : nullptr),
        floats(o.floats),
        ints(o.ints),
        strings(o.strings) {
  tensors.reserve(o.tensors.size());
  for (const auto &tensors_ : o.tensors) { tensors.emplace_back((tensors_) ? new onnxruntime::fbs::TTensor(*tensors_) : nullptr); }
  graphs.reserve(o.graphs.size());
  for (const auto &graphs_ : o.graphs) { graphs.emplace_back((graphs_) ? new onnxruntime::fbs::TGraph(*graphs_) : nullptr); }
}

inline TAttribute &TAttribute::operator=(TAttribute o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(doc_string, o.doc_string);
  std::swap(type, o.type);
  std::swap(f, o.f);
  std::swap(i, o.i);
  std::swap(s, o.s);
  std::swap(t, o.t);
  std::swap(g, o.g);
  std::swap(floats, o.floats);
  std::swap(ints, o.ints);
  std::swap(strings, o.strings);
  std::swap(tensors, o.tensors);
  std::swap(graphs, o.graphs);
  return *this;
}

inline TAttribute *Attribute::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TAttribute>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Attribute::UnPackTo(TAttribute *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = doc_string(); if (_e) _o->doc_string = _e->str(); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = f(); _o->f = _e; }
  { auto _e = i(); _o->i = _e; }
  { auto _e = s(); if (_e) _o->s = _e->str(); }
  { auto _e = t(); if (_e) { if(_o->t) { _e->UnPackTo(_o->t.get(), _resolver); } else { _o->t = std::unique_ptr<onnxruntime::fbs::TTensor>(_e->UnPack(_resolver)); } } else if (_o->t) { _o->t.reset(); } }
  { auto _e = g(); if (_e) { if(_o->g) { _e->UnPackTo(_o->g.get(), _resolver); } else { _o->g = std::unique_ptr<onnxruntime::fbs::TGraph>(_e->UnPack(_resolver)); } } else if (_o->g) { _o->g.reset(); } }
  { auto _e = floats(); if (_e) { _o->floats.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->floats[_i] = _e->Get(_i); } } else { _o->floats.resize(0); } }
  { auto _e = ints(); if (_e) { _o->ints.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ints[_i] = _e->Get(_i); } } else { _o->ints.resize(0); } }
  { auto _e = strings(); if (_e) { _o->strings.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strings[_i] = _e->Get(_i)->str(); } } else { _o->strings.resize(0); } }
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tensors[_i]) { _e->Get(_i)->UnPackTo(_o->tensors[_i].get(), _resolver); } else { _o->tensors[_i] = std::unique_ptr<onnxruntime::fbs::TTensor>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tensors.resize(0); } }
  { auto _e = graphs(); if (_e) { _o->graphs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->graphs[_i]) { _e->Get(_i)->UnPackTo(_o->graphs[_i].get(), _resolver); } else { _o->graphs[_i] = std::unique_ptr<onnxruntime::fbs::TGraph>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->graphs.resize(0); } }
}

inline ::flatbuffers::Offset<Attribute> Attribute::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TAttribute* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttribute(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Attribute> CreateAttribute(::flatbuffers::FlatBufferBuilder &_fbb, const TAttribute *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TAttribute* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _doc_string = _o->doc_string.empty() ? 0 : _fbb.CreateString(_o->doc_string);
  auto _type = _o->type;
  auto _f = _o->f;
  auto _i = _o->i;
  auto _s = _o->s.empty() ? 0 : _fbb.CreateString(_o->s);
  auto _t = _o->t ? CreateTensor(_fbb, _o->t.get(), _rehasher) : 0;
  auto _g = _o->g ? CreateGraph(_fbb, _o->g.get(), _rehasher) : 0;
  auto _floats = _o->floats.size() ? _fbb.CreateVector(_o->floats) : 0;
  auto _ints = _o->ints.size() ? _fbb.CreateVector(_o->ints) : 0;
  auto _strings = _o->strings.size() ? _fbb.CreateVectorOfStrings(_o->strings) : 0;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> (_o->tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _graphs = _o->graphs.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Graph>> (_o->graphs.size(), [](size_t i, _VectorArgs *__va) { return CreateGraph(*__va->__fbb, __va->__o->graphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateAttribute(
      _fbb,
      _name,
      _doc_string,
      _type,
      _f,
      _i,
      _s,
      _t,
      _g,
      _floats,
      _ints,
      _strings,
      _tensors,
      _graphs);
}


inline bool operator==(const TNodesToOptimizeIndices &lhs, const TNodesToOptimizeIndices &rhs) {
  return
      (lhs.node_indices == rhs.node_indices) &&
      (lhs.num_inputs == rhs.num_inputs) &&
      (lhs.num_outputs == rhs.num_outputs) &&
      (lhs.has_variadic_input == rhs.has_variadic_input) &&
      (lhs.has_variadic_output == rhs.has_variadic_output) &&
      (lhs.num_variadic_inputs == rhs.num_variadic_inputs) &&
      (lhs.num_variadic_outputs == rhs.num_variadic_outputs);
}

inline bool operator!=(const TNodesToOptimizeIndices &lhs, const TNodesToOptimizeIndices &rhs) {
    return !(lhs == rhs);
}


inline TNodesToOptimizeIndices *NodesToOptimizeIndices::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TNodesToOptimizeIndices>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NodesToOptimizeIndices::UnPackTo(TNodesToOptimizeIndices *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = node_indices(); if (_e) { _o->node_indices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->node_indices[_i] = _e->Get(_i); } } else { _o->node_indices.resize(0); } }
  { auto _e = num_inputs(); _o->num_inputs = _e; }
  { auto _e = num_outputs(); _o->num_outputs = _e; }
  { auto _e = has_variadic_input(); _o->has_variadic_input = _e; }
  { auto _e = has_variadic_output(); _o->has_variadic_output = _e; }
  { auto _e = num_variadic_inputs(); _o->num_variadic_inputs = _e; }
  { auto _e = num_variadic_outputs(); _o->num_variadic_outputs = _e; }
}

inline ::flatbuffers::Offset<NodesToOptimizeIndices> NodesToOptimizeIndices::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TNodesToOptimizeIndices* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNodesToOptimizeIndices(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NodesToOptimizeIndices> CreateNodesToOptimizeIndices(::flatbuffers::FlatBufferBuilder &_fbb, const TNodesToOptimizeIndices *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TNodesToOptimizeIndices* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _node_indices = _o->node_indices.size() ? _fbb.CreateVector(_o->node_indices) : 0;
  auto _num_inputs = _o->num_inputs;
  auto _num_outputs = _o->num_outputs;
  auto _has_variadic_input = _o->has_variadic_input;
  auto _has_variadic_output = _o->has_variadic_output;
  auto _num_variadic_inputs = _o->num_variadic_inputs;
  auto _num_variadic_outputs = _o->num_variadic_outputs;
  return onnxruntime::fbs::CreateNodesToOptimizeIndices(
      _fbb,
      _node_indices,
      _num_inputs,
      _num_outputs,
      _has_variadic_input,
      _has_variadic_output,
      _num_variadic_inputs,
      _num_variadic_outputs);
}


inline bool operator==(const TDeprecatedNodeIndexAndKernelDefHash &lhs, const TDeprecatedNodeIndexAndKernelDefHash &rhs) {
  return
      (lhs.node_index == rhs.node_index) &&
      (lhs.kernel_def_hash == rhs.kernel_def_hash);
}

inline bool operator!=(const TDeprecatedNodeIndexAndKernelDefHash &lhs, const TDeprecatedNodeIndexAndKernelDefHash &rhs) {
    return !(lhs == rhs);
}


inline TDeprecatedNodeIndexAndKernelDefHash *DeprecatedNodeIndexAndKernelDefHash::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TDeprecatedNodeIndexAndKernelDefHash>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeprecatedNodeIndexAndKernelDefHash::UnPackTo(TDeprecatedNodeIndexAndKernelDefHash *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = node_index(); _o->node_index = _e; }
  { auto _e = kernel_def_hash(); _o->kernel_def_hash = _e; }
}

inline ::flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash> DeprecatedNodeIndexAndKernelDefHash::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedNodeIndexAndKernelDefHash* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeprecatedNodeIndexAndKernelDefHash(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash> CreateDeprecatedNodeIndexAndKernelDefHash(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedNodeIndexAndKernelDefHash *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDeprecatedNodeIndexAndKernelDefHash* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _node_index = _o->node_index;
  auto _kernel_def_hash = _o->kernel_def_hash;
  return onnxruntime::fbs::CreateDeprecatedNodeIndexAndKernelDefHash(
      _fbb,
      _node_index,
      _kernel_def_hash);
}


inline bool operator==(const TRuntimeOptimizationRecord &lhs, const TRuntimeOptimizationRecord &rhs) {
  return
      (lhs.action_id == rhs.action_id) &&
      ((lhs.nodes_to_optimize_indices == rhs.nodes_to_optimize_indices) || (lhs.nodes_to_optimize_indices && rhs.nodes_to_optimize_indices && *lhs.nodes_to_optimize_indices == *rhs.nodes_to_optimize_indices)) &&
      (lhs.produced_op_ids == rhs.produced_op_ids);
}

inline bool operator!=(const TRuntimeOptimizationRecord &lhs, const TRuntimeOptimizationRecord &rhs) {
    return !(lhs == rhs);
}


inline TRuntimeOptimizationRecord::TRuntimeOptimizationRecord(const TRuntimeOptimizationRecord &o)
      : action_id(o.action_id),
        nodes_to_optimize_indices((o.nodes_to_optimize_indices) ? new onnxruntime::fbs::TNodesToOptimizeIndices(*o.nodes_to_optimize_indices) : nullptr),
        produced_op_ids(o.produced_op_ids) {
}

inline TRuntimeOptimizationRecord &TRuntimeOptimizationRecord::operator=(TRuntimeOptimizationRecord o) FLATBUFFERS_NOEXCEPT {
  std::swap(action_id, o.action_id);
  std::swap(nodes_to_optimize_indices, o.nodes_to_optimize_indices);
  std::swap(produced_op_ids, o.produced_op_ids);
  return *this;
}

inline TRuntimeOptimizationRecord *RuntimeOptimizationRecord::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TRuntimeOptimizationRecord>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuntimeOptimizationRecord::UnPackTo(TRuntimeOptimizationRecord *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action_id(); if (_e) _o->action_id = _e->str(); }
  { auto _e = nodes_to_optimize_indices(); if (_e) { if(_o->nodes_to_optimize_indices) { _e->UnPackTo(_o->nodes_to_optimize_indices.get(), _resolver); } else { _o->nodes_to_optimize_indices = std::unique_ptr<onnxruntime::fbs::TNodesToOptimizeIndices>(_e->UnPack(_resolver)); } } else if (_o->nodes_to_optimize_indices) { _o->nodes_to_optimize_indices.reset(); } }
  { auto _e = produced_op_ids(); if (_e) { _o->produced_op_ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->produced_op_ids[_i] = _e->Get(_i)->str(); } } else { _o->produced_op_ids.resize(0); } }
}

inline ::flatbuffers::Offset<RuntimeOptimizationRecord> RuntimeOptimizationRecord::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizationRecord* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuntimeOptimizationRecord(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RuntimeOptimizationRecord> CreateRuntimeOptimizationRecord(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizationRecord *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TRuntimeOptimizationRecord* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action_id = _o->action_id.empty() ? 0 : _fbb.CreateString(_o->action_id);
  auto _nodes_to_optimize_indices = _o->nodes_to_optimize_indices ? CreateNodesToOptimizeIndices(_fbb, _o->nodes_to_optimize_indices.get(), _rehasher) : 0;
  auto _produced_op_ids = _o->produced_op_ids.size() ? _fbb.CreateVectorOfStrings(_o->produced_op_ids) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizationRecord(
      _fbb,
      _action_id,
      _nodes_to_optimize_indices,
      _produced_op_ids);
}


inline bool operator==(const TRuntimeOptimizationRecordContainerEntry &lhs, const TRuntimeOptimizationRecordContainerEntry &rhs) {
  return
      (lhs.optimizer_name == rhs.optimizer_name) &&
      (lhs.runtime_optimization_records.size() == rhs.runtime_optimization_records.size() && std::equal(lhs.runtime_optimization_records.cbegin(), lhs.runtime_optimization_records.cend(), rhs.runtime_optimization_records.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizationRecord> const &a, std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizationRecord> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TRuntimeOptimizationRecordContainerEntry &lhs, const TRuntimeOptimizationRecordContainerEntry &rhs) {
    return !(lhs == rhs);
}


inline TRuntimeOptimizationRecordContainerEntry::TRuntimeOptimizationRecordContainerEntry(const TRuntimeOptimizationRecordContainerEntry &o)
      : optimizer_name(o.optimizer_name) {
  runtime_optimization_records.reserve(o.runtime_optimization_records.size());
  for (const auto &runtime_optimization_records_ : o.runtime_optimization_records) { runtime_optimization_records.emplace_back((runtime_optimization_records_) ? new onnxruntime::fbs::TRuntimeOptimizationRecord(*runtime_optimization_records_) : nullptr); }
}

inline TRuntimeOptimizationRecordContainerEntry &TRuntimeOptimizationRecordContainerEntry::operator=(TRuntimeOptimizationRecordContainerEntry o) FLATBUFFERS_NOEXCEPT {
  std::swap(optimizer_name, o.optimizer_name);
  std::swap(runtime_optimization_records, o.runtime_optimization_records);
  return *this;
}

inline TRuntimeOptimizationRecordContainerEntry *RuntimeOptimizationRecordContainerEntry::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TRuntimeOptimizationRecordContainerEntry>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuntimeOptimizationRecordContainerEntry::UnPackTo(TRuntimeOptimizationRecordContainerEntry *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = optimizer_name(); if (_e) _o->optimizer_name = _e->str(); }
  { auto _e = runtime_optimization_records(); if (_e) { _o->runtime_optimization_records.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->runtime_optimization_records[_i]) { _e->Get(_i)->UnPackTo(_o->runtime_optimization_records[_i].get(), _resolver); } else { _o->runtime_optimization_records[_i] = std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizationRecord>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->runtime_optimization_records.resize(0); } }
}

inline ::flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> RuntimeOptimizationRecordContainerEntry::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizationRecordContainerEntry* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuntimeOptimizationRecordContainerEntry(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> CreateRuntimeOptimizationRecordContainerEntry(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizationRecordContainerEntry *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TRuntimeOptimizationRecordContainerEntry* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _optimizer_name = _fbb.CreateString(_o->optimizer_name);
  auto _runtime_optimization_records = _o->runtime_optimization_records.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> (_o->runtime_optimization_records.size(), [](size_t i, _VectorArgs *__va) { return CreateRuntimeOptimizationRecord(*__va->__fbb, __va->__o->runtime_optimization_records[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizationRecordContainerEntry(
      _fbb,
      _optimizer_name,
      _runtime_optimization_records);
}


inline bool operator==(const TRuntimeOptimizations &lhs, const TRuntimeOptimizations &rhs) {
  return
      (lhs.records.size() == rhs.records.size() && std::equal(lhs.records.cbegin(), lhs.records.cend(), rhs.records.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizationRecordContainerEntry> const &a, std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizationRecordContainerEntry> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TRuntimeOptimizations &lhs, const TRuntimeOptimizations &rhs) {
    return !(lhs == rhs);
}


inline TRuntimeOptimizations::TRuntimeOptimizations(const TRuntimeOptimizations &o) {
  records.reserve(o.records.size());
  for (const auto &records_ : o.records) { records.emplace_back((records_) ? new onnxruntime::fbs::TRuntimeOptimizationRecordContainerEntry(*records_) : nullptr); }
}

inline TRuntimeOptimizations &TRuntimeOptimizations::operator=(TRuntimeOptimizations o) FLATBUFFERS_NOEXCEPT {
  std::swap(records, o.records);
  return *this;
}

inline TRuntimeOptimizations *RuntimeOptimizations::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TRuntimeOptimizations>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuntimeOptimizations::UnPackTo(TRuntimeOptimizations *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = records(); if (_e) { _o->records.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->records[_i]) { _e->Get(_i)->UnPackTo(_o->records[_i].get(), _resolver); } else { _o->records[_i] = std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizationRecordContainerEntry>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->records.resize(0); } }
}

inline ::flatbuffers::Offset<RuntimeOptimizations> RuntimeOptimizations::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizations* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuntimeOptimizations(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RuntimeOptimizations> CreateRuntimeOptimizations(::flatbuffers::FlatBufferBuilder &_fbb, const TRuntimeOptimizations *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TRuntimeOptimizations* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _records = _o->records.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> (_o->records.size(), [](size_t i, _VectorArgs *__va) { return CreateRuntimeOptimizationRecordContainerEntry(*__va->__fbb, __va->__o->records[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizations(
      _fbb,
      _records);
}


inline bool operator==(const TGraph &lhs, const TGraph &rhs) {
  return
      (lhs.initializers.size() == rhs.initializers.size() && std::equal(lhs.initializers.cbegin(), lhs.initializers.cend(), rhs.initializers.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TTensor> const &a, std::unique_ptr<onnxruntime::fbs::TTensor> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.node_args.size() == rhs.node_args.size() && std::equal(lhs.node_args.cbegin(), lhs.node_args.cend(), rhs.node_args.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TValueInfo> const &a, std::unique_ptr<onnxruntime::fbs::TValueInfo> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.nodes.size() == rhs.nodes.size() && std::equal(lhs.nodes.cbegin(), lhs.nodes.cend(), rhs.nodes.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TNode> const &a, std::unique_ptr<onnxruntime::fbs::TNode> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.max_node_index == rhs.max_node_index) &&
      (lhs.node_edges.size() == rhs.node_edges.size() && std::equal(lhs.node_edges.cbegin(), lhs.node_edges.cend(), rhs.node_edges.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TNodeEdge> const &a, std::unique_ptr<onnxruntime::fbs::TNodeEdge> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.inputs == rhs.inputs) &&
      (lhs.outputs == rhs.outputs) &&
      (lhs.sparse_initializers.size() == rhs.sparse_initializers.size() && std::equal(lhs.sparse_initializers.cbegin(), lhs.sparse_initializers.cend(), rhs.sparse_initializers.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TSparseTensor> const &a, std::unique_ptr<onnxruntime::fbs::TSparseTensor> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      ((lhs.runtime_optimizations == rhs.runtime_optimizations) || (lhs.runtime_optimizations && rhs.runtime_optimizations && *lhs.runtime_optimizations == *rhs.runtime_optimizations));
}

inline bool operator!=(const TGraph &lhs, const TGraph &rhs) {
    return !(lhs == rhs);
}


inline TGraph::TGraph(const TGraph &o)
      : max_node_index(o.max_node_index),
        inputs(o.inputs),
        outputs(o.outputs),
        runtime_optimizations((o.runtime_optimizations) ? new onnxruntime::fbs::TRuntimeOptimizations(*o.runtime_optimizations) : nullptr) {
  initializers.reserve(o.initializers.size());
  for (const auto &initializers_ : o.initializers) { initializers.emplace_back((initializers_) ? new onnxruntime::fbs::TTensor(*initializers_) : nullptr); }
  node_args.reserve(o.node_args.size());
  for (const auto &node_args_ : o.node_args) { node_args.emplace_back((node_args_) ? new onnxruntime::fbs::TValueInfo(*node_args_) : nullptr); }
  nodes.reserve(o.nodes.size());
  for (const auto &nodes_ : o.nodes) { nodes.emplace_back((nodes_) ? new onnxruntime::fbs::TNode(*nodes_) : nullptr); }
  node_edges.reserve(o.node_edges.size());
  for (const auto &node_edges_ : o.node_edges) { node_edges.emplace_back((node_edges_) ? new onnxruntime::fbs::TNodeEdge(*node_edges_) : nullptr); }
  sparse_initializers.reserve(o.sparse_initializers.size());
  for (const auto &sparse_initializers_ : o.sparse_initializers) { sparse_initializers.emplace_back((sparse_initializers_) ? new onnxruntime::fbs::TSparseTensor(*sparse_initializers_) : nullptr); }
}

inline TGraph &TGraph::operator=(TGraph o) FLATBUFFERS_NOEXCEPT {
  std::swap(initializers, o.initializers);
  std::swap(node_args, o.node_args);
  std::swap(nodes, o.nodes);
  std::swap(max_node_index, o.max_node_index);
  std::swap(node_edges, o.node_edges);
  std::swap(inputs, o.inputs);
  std::swap(outputs, o.outputs);
  std::swap(sparse_initializers, o.sparse_initializers);
  std::swap(runtime_optimizations, o.runtime_optimizations);
  return *this;
}

inline TGraph *Graph::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TGraph>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Graph::UnPackTo(TGraph *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = initializers(); if (_e) { _o->initializers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->initializers[_i]) { _e->Get(_i)->UnPackTo(_o->initializers[_i].get(), _resolver); } else { _o->initializers[_i] = std::unique_ptr<onnxruntime::fbs::TTensor>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->initializers.resize(0); } }
  { auto _e = node_args(); if (_e) { _o->node_args.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->node_args[_i]) { _e->Get(_i)->UnPackTo(_o->node_args[_i].get(), _resolver); } else { _o->node_args[_i] = std::unique_ptr<onnxruntime::fbs::TValueInfo>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->node_args.resize(0); } }
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->nodes[_i]) { _e->Get(_i)->UnPackTo(_o->nodes[_i].get(), _resolver); } else { _o->nodes[_i] = std::unique_ptr<onnxruntime::fbs::TNode>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->nodes.resize(0); } }
  { auto _e = max_node_index(); _o->max_node_index = _e; }
  { auto _e = node_edges(); if (_e) { _o->node_edges.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->node_edges[_i]) { _e->Get(_i)->UnPackTo(_o->node_edges[_i].get(), _resolver); } else { _o->node_edges[_i] = std::unique_ptr<onnxruntime::fbs::TNodeEdge>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->node_edges.resize(0); } }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i)->str(); } } else { _o->inputs.resize(0); } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i)->str(); } } else { _o->outputs.resize(0); } }
  { auto _e = sparse_initializers(); if (_e) { _o->sparse_initializers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->sparse_initializers[_i]) { _e->Get(_i)->UnPackTo(_o->sparse_initializers[_i].get(), _resolver); } else { _o->sparse_initializers[_i] = std::unique_ptr<onnxruntime::fbs::TSparseTensor>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->sparse_initializers.resize(0); } }
  { auto _e = runtime_optimizations(); if (_e) { if(_o->runtime_optimizations) { _e->UnPackTo(_o->runtime_optimizations.get(), _resolver); } else { _o->runtime_optimizations = std::unique_ptr<onnxruntime::fbs::TRuntimeOptimizations>(_e->UnPack(_resolver)); } } else if (_o->runtime_optimizations) { _o->runtime_optimizations.reset(); } }
}

inline ::flatbuffers::Offset<Graph> Graph::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TGraph* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGraph(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Graph> CreateGraph(::flatbuffers::FlatBufferBuilder &_fbb, const TGraph *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TGraph* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _initializers = _o->initializers.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Tensor>> (_o->initializers.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->initializers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _node_args = _o->node_args.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> (_o->node_args.size(), [](size_t i, _VectorArgs *__va) { return CreateValueInfo(*__va->__fbb, __va->__o->node_args[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::Node>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateNode(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _max_node_index = _o->max_node_index;
  auto _node_edges = _o->node_edges.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> (_o->node_edges.size(), [](size_t i, _VectorArgs *__va) { return CreateNodeEdge(*__va->__fbb, __va->__o->node_edges[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVectorOfStrings(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVectorOfStrings(_o->outputs) : 0;
  auto _sparse_initializers = _o->sparse_initializers.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> (_o->sparse_initializers.size(), [](size_t i, _VectorArgs *__va) { return CreateSparseTensor(*__va->__fbb, __va->__o->sparse_initializers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _runtime_optimizations = _o->runtime_optimizations ? CreateRuntimeOptimizations(_fbb, _o->runtime_optimizations.get(), _rehasher) : 0;
  return onnxruntime::fbs::CreateGraph(
      _fbb,
      _initializers,
      _node_args,
      _nodes,
      _max_node_index,
      _node_edges,
      _inputs,
      _outputs,
      _sparse_initializers,
      _runtime_optimizations);
}


inline bool operator==(const TStringStringEntry &lhs, const TStringStringEntry &rhs) {
  return
      (lhs.key == rhs.key) &&
      (lhs.value == rhs.value);
}

inline bool operator!=(const TStringStringEntry &lhs, const TStringStringEntry &rhs) {
    return !(lhs == rhs);
}


inline TStringStringEntry *StringStringEntry::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TStringStringEntry>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StringStringEntry::UnPackTo(TStringStringEntry *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline ::flatbuffers::Offset<StringStringEntry> StringStringEntry::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TStringStringEntry* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringStringEntry(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StringStringEntry> CreateStringStringEntry(::flatbuffers::FlatBufferBuilder &_fbb, const TStringStringEntry *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TStringStringEntry* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _o->key.empty() ? 0 : _fbb.CreateString(_o->key);
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  return onnxruntime::fbs::CreateStringStringEntry(
      _fbb,
      _key,
      _value);
}


inline bool operator==(const TModel &lhs, const TModel &rhs) {
  return
      (lhs.ir_version == rhs.ir_version) &&
      (lhs.opset_import.size() == rhs.opset_import.size() && std::equal(lhs.opset_import.cbegin(), lhs.opset_import.cend(), rhs.opset_import.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TOperatorSetId> const &a, std::unique_ptr<onnxruntime::fbs::TOperatorSetId> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.producer_name == rhs.producer_name) &&
      (lhs.producer_version == rhs.producer_version) &&
      (lhs.domain == rhs.domain) &&
      (lhs.model_version == rhs.model_version) &&
      (lhs.doc_string == rhs.doc_string) &&
      ((lhs.graph == rhs.graph) || (lhs.graph && rhs.graph && *lhs.graph == *rhs.graph)) &&
      (lhs.graph_doc_string == rhs.graph_doc_string) &&
      (lhs.metadata_props.size() == rhs.metadata_props.size() && std::equal(lhs.metadata_props.cbegin(), lhs.metadata_props.cend(), rhs.metadata_props.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TStringStringEntry> const &a, std::unique_ptr<onnxruntime::fbs::TStringStringEntry> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TModel &lhs, const TModel &rhs) {
    return !(lhs == rhs);
}


inline TModel::TModel(const TModel &o)
      : ir_version(o.ir_version),
        producer_name(o.producer_name),
        producer_version(o.producer_version),
        domain(o.domain),
        model_version(o.model_version),
        doc_string(o.doc_string),
        graph((o.graph) ? new onnxruntime::fbs::TGraph(*o.graph) : nullptr),
        graph_doc_string(o.graph_doc_string) {
  opset_import.reserve(o.opset_import.size());
  for (const auto &opset_import_ : o.opset_import) { opset_import.emplace_back((opset_import_) ? new onnxruntime::fbs::TOperatorSetId(*opset_import_) : nullptr); }
  metadata_props.reserve(o.metadata_props.size());
  for (const auto &metadata_props_ : o.metadata_props) { metadata_props.emplace_back((metadata_props_) ? new onnxruntime::fbs::TStringStringEntry(*metadata_props_) : nullptr); }
}

inline TModel &TModel::operator=(TModel o) FLATBUFFERS_NOEXCEPT {
  std::swap(ir_version, o.ir_version);
  std::swap(opset_import, o.opset_import);
  std::swap(producer_name, o.producer_name);
  std::swap(producer_version, o.producer_version);
  std::swap(domain, o.domain);
  std::swap(model_version, o.model_version);
  std::swap(doc_string, o.doc_string);
  std::swap(graph, o.graph);
  std::swap(graph_doc_string, o.graph_doc_string);
  std::swap(metadata_props, o.metadata_props);
  return *this;
}

inline TModel *Model::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TModel>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Model::UnPackTo(TModel *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ir_version(); _o->ir_version = _e; }
  { auto _e = opset_import(); if (_e) { _o->opset_import.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->opset_import[_i]) { _e->Get(_i)->UnPackTo(_o->opset_import[_i].get(), _resolver); } else { _o->opset_import[_i] = std::unique_ptr<onnxruntime::fbs::TOperatorSetId>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->opset_import.resize(0); } }
  { auto _e = producer_name(); if (_e) _o->producer_name = _e->str(); }
  { auto _e = producer_version(); if (_e) _o->producer_version = _e->str(); }
  { auto _e = domain(); if (_e) _o->domain = _e->str(); }
  { auto _e = model_version(); _o->model_version = _e; }
  { auto _e = doc_string(); if (_e) _o->doc_string = _e->str(); }
  { auto _e = graph(); if (_e) { if(_o->graph) { _e->UnPackTo(_o->graph.get(), _resolver); } else { _o->graph = std::unique_ptr<onnxruntime::fbs::TGraph>(_e->UnPack(_resolver)); } } else if (_o->graph) { _o->graph.reset(); } }
  { auto _e = graph_doc_string(); if (_e) _o->graph_doc_string = _e->str(); }
  { auto _e = metadata_props(); if (_e) { _o->metadata_props.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->metadata_props[_i]) { _e->Get(_i)->UnPackTo(_o->metadata_props[_i].get(), _resolver); } else { _o->metadata_props[_i] = std::unique_ptr<onnxruntime::fbs::TStringStringEntry>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->metadata_props.resize(0); } }
}

inline ::flatbuffers::Offset<Model> Model::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModel* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModel(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Model> CreateModel(::flatbuffers::FlatBufferBuilder &_fbb, const TModel *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TModel* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ir_version = _o->ir_version;
  auto _opset_import = _o->opset_import.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> (_o->opset_import.size(), [](size_t i, _VectorArgs *__va) { return CreateOperatorSetId(*__va->__fbb, __va->__o->opset_import[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _producer_name = _o->producer_name.empty() ? 0 : _fbb.CreateString(_o->producer_name);
  auto _producer_version = _o->producer_version.empty() ? 0 : _fbb.CreateString(_o->producer_version);
  auto _domain = _o->domain.empty() ? 0 : _fbb.CreateString(_o->domain);
  auto _model_version = _o->model_version;
  auto _doc_string = _o->doc_string.empty() ? 0 : _fbb.CreateString(_o->doc_string);
  auto _graph = _o->graph ? CreateGraph(_fbb, _o->graph.get(), _rehasher) : 0;
  auto _graph_doc_string = _o->graph_doc_string.empty() ? 0 : _fbb.CreateString(_o->graph_doc_string);
  auto _metadata_props = _o->metadata_props.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> (_o->metadata_props.size(), [](size_t i, _VectorArgs *__va) { return CreateStringStringEntry(*__va->__fbb, __va->__o->metadata_props[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateModel(
      _fbb,
      _ir_version,
      _opset_import,
      _producer_name,
      _producer_version,
      _domain,
      _model_version,
      _doc_string,
      _graph,
      _graph_doc_string,
      _metadata_props);
}


inline bool operator==(const TDeprecatedKernelCreateInfos &lhs, const TDeprecatedKernelCreateInfos &rhs) {
  return
      (lhs.node_indices == rhs.node_indices) &&
      (lhs.kernel_def_hashes == rhs.kernel_def_hashes);
}

inline bool operator!=(const TDeprecatedKernelCreateInfos &lhs, const TDeprecatedKernelCreateInfos &rhs) {
    return !(lhs == rhs);
}


inline TDeprecatedKernelCreateInfos *DeprecatedKernelCreateInfos::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TDeprecatedKernelCreateInfos>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeprecatedKernelCreateInfos::UnPackTo(TDeprecatedKernelCreateInfos *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = node_indices(); if (_e) { _o->node_indices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->node_indices[_i] = _e->Get(_i); } } else { _o->node_indices.resize(0); } }
  { auto _e = kernel_def_hashes(); if (_e) { _o->kernel_def_hashes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_def_hashes[_i] = _e->Get(_i); } } else { _o->kernel_def_hashes.resize(0); } }
}

inline ::flatbuffers::Offset<DeprecatedKernelCreateInfos> DeprecatedKernelCreateInfos::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedKernelCreateInfos* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeprecatedKernelCreateInfos(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeprecatedKernelCreateInfos> CreateDeprecatedKernelCreateInfos(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedKernelCreateInfos *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDeprecatedKernelCreateInfos* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _node_indices = _o->node_indices.size() ? _fbb.CreateVector(_o->node_indices) : 0;
  auto _kernel_def_hashes = _o->kernel_def_hashes.size() ? _fbb.CreateVector(_o->kernel_def_hashes) : 0;
  return onnxruntime::fbs::CreateDeprecatedKernelCreateInfos(
      _fbb,
      _node_indices,
      _kernel_def_hashes);
}


inline bool operator==(const TDeprecatedSubGraphSessionState &lhs, const TDeprecatedSubGraphSessionState &rhs) {
  return
      (lhs.graph_id == rhs.graph_id) &&
      ((lhs.session_state == rhs.session_state) || (lhs.session_state && rhs.session_state && *lhs.session_state == *rhs.session_state));
}

inline bool operator!=(const TDeprecatedSubGraphSessionState &lhs, const TDeprecatedSubGraphSessionState &rhs) {
    return !(lhs == rhs);
}


inline TDeprecatedSubGraphSessionState::TDeprecatedSubGraphSessionState(const TDeprecatedSubGraphSessionState &o)
      : graph_id(o.graph_id),
        session_state((o.session_state) ? new onnxruntime::fbs::TDeprecatedSessionState(*o.session_state) : nullptr) {
}

inline TDeprecatedSubGraphSessionState &TDeprecatedSubGraphSessionState::operator=(TDeprecatedSubGraphSessionState o) FLATBUFFERS_NOEXCEPT {
  std::swap(graph_id, o.graph_id);
  std::swap(session_state, o.session_state);
  return *this;
}

inline TDeprecatedSubGraphSessionState *DeprecatedSubGraphSessionState::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TDeprecatedSubGraphSessionState>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeprecatedSubGraphSessionState::UnPackTo(TDeprecatedSubGraphSessionState *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = graph_id(); if (_e) _o->graph_id = _e->str(); }
  { auto _e = session_state(); if (_e) { if(_o->session_state) { _e->UnPackTo(_o->session_state.get(), _resolver); } else { _o->session_state = std::unique_ptr<onnxruntime::fbs::TDeprecatedSessionState>(_e->UnPack(_resolver)); } } else if (_o->session_state) { _o->session_state.reset(); } }
}

inline ::flatbuffers::Offset<DeprecatedSubGraphSessionState> DeprecatedSubGraphSessionState::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedSubGraphSessionState* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeprecatedSubGraphSessionState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeprecatedSubGraphSessionState> CreateDeprecatedSubGraphSessionState(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedSubGraphSessionState *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDeprecatedSubGraphSessionState* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _graph_id = _fbb.CreateString(_o->graph_id);
  auto _session_state = _o->session_state ? CreateDeprecatedSessionState(_fbb, _o->session_state.get(), _rehasher) : 0;
  return onnxruntime::fbs::CreateDeprecatedSubGraphSessionState(
      _fbb,
      _graph_id,
      _session_state);
}


inline bool operator==(const TDeprecatedSessionState &lhs, const TDeprecatedSessionState &rhs) {
  return
      ((lhs.kernels == rhs.kernels) || (lhs.kernels && rhs.kernels && *lhs.kernels == *rhs.kernels)) &&
      (lhs.sub_graph_session_states.size() == rhs.sub_graph_session_states.size() && std::equal(lhs.sub_graph_session_states.cbegin(), lhs.sub_graph_session_states.cend(), rhs.sub_graph_session_states.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TDeprecatedSubGraphSessionState> const &a, std::unique_ptr<onnxruntime::fbs::TDeprecatedSubGraphSessionState> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TDeprecatedSessionState &lhs, const TDeprecatedSessionState &rhs) {
    return !(lhs == rhs);
}


inline TDeprecatedSessionState::TDeprecatedSessionState(const TDeprecatedSessionState &o)
      : kernels((o.kernels) ? new onnxruntime::fbs::TDeprecatedKernelCreateInfos(*o.kernels) : nullptr) {
  sub_graph_session_states.reserve(o.sub_graph_session_states.size());
  for (const auto &sub_graph_session_states_ : o.sub_graph_session_states) { sub_graph_session_states.emplace_back((sub_graph_session_states_) ? new onnxruntime::fbs::TDeprecatedSubGraphSessionState(*sub_graph_session_states_) : nullptr); }
}

inline TDeprecatedSessionState &TDeprecatedSessionState::operator=(TDeprecatedSessionState o) FLATBUFFERS_NOEXCEPT {
  std::swap(kernels, o.kernels);
  std::swap(sub_graph_session_states, o.sub_graph_session_states);
  return *this;
}

inline TDeprecatedSessionState *DeprecatedSessionState::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TDeprecatedSessionState>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeprecatedSessionState::UnPackTo(TDeprecatedSessionState *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernels(); if (_e) { if(_o->kernels) { _e->UnPackTo(_o->kernels.get(), _resolver); } else { _o->kernels = std::unique_ptr<onnxruntime::fbs::TDeprecatedKernelCreateInfos>(_e->UnPack(_resolver)); } } else if (_o->kernels) { _o->kernels.reset(); } }
  { auto _e = sub_graph_session_states(); if (_e) { _o->sub_graph_session_states.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->sub_graph_session_states[_i]) { _e->Get(_i)->UnPackTo(_o->sub_graph_session_states[_i].get(), _resolver); } else { _o->sub_graph_session_states[_i] = std::unique_ptr<onnxruntime::fbs::TDeprecatedSubGraphSessionState>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->sub_graph_session_states.resize(0); } }
}

inline ::flatbuffers::Offset<DeprecatedSessionState> DeprecatedSessionState::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedSessionState* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeprecatedSessionState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeprecatedSessionState> CreateDeprecatedSessionState(::flatbuffers::FlatBufferBuilder &_fbb, const TDeprecatedSessionState *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDeprecatedSessionState* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernels = _o->kernels ? CreateDeprecatedKernelCreateInfos(_fbb, _o->kernels.get(), _rehasher) : 0;
  auto _sub_graph_session_states = _o->sub_graph_session_states.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> (_o->sub_graph_session_states.size(), [](size_t i, _VectorArgs *__va) { return CreateDeprecatedSubGraphSessionState(*__va->__fbb, __va->__o->sub_graph_session_states[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateDeprecatedSessionState(
      _fbb,
      _kernels,
      _sub_graph_session_states);
}


inline bool operator==(const TArgTypeAndIndex &lhs, const TArgTypeAndIndex &rhs) {
  return
      (lhs.arg_type == rhs.arg_type) &&
      (lhs.index == rhs.index);
}

inline bool operator!=(const TArgTypeAndIndex &lhs, const TArgTypeAndIndex &rhs) {
    return !(lhs == rhs);
}


inline TArgTypeAndIndex *ArgTypeAndIndex::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TArgTypeAndIndex>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgTypeAndIndex::UnPackTo(TArgTypeAndIndex *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = arg_type(); _o->arg_type = _e; }
  { auto _e = index(); _o->index = _e; }
}

inline ::flatbuffers::Offset<ArgTypeAndIndex> ArgTypeAndIndex::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TArgTypeAndIndex* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgTypeAndIndex(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ArgTypeAndIndex> CreateArgTypeAndIndex(::flatbuffers::FlatBufferBuilder &_fbb, const TArgTypeAndIndex *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TArgTypeAndIndex* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _arg_type = _o->arg_type;
  auto _index = _o->index;
  return onnxruntime::fbs::CreateArgTypeAndIndex(
      _fbb,
      _arg_type,
      _index);
}


inline bool operator==(const TKernelTypeStrArgsEntry &lhs, const TKernelTypeStrArgsEntry &rhs) {
  return
      (lhs.kernel_type_str == rhs.kernel_type_str) &&
      (lhs.args.size() == rhs.args.size() && std::equal(lhs.args.cbegin(), lhs.args.cend(), rhs.args.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TArgTypeAndIndex> const &a, std::unique_ptr<onnxruntime::fbs::TArgTypeAndIndex> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TKernelTypeStrArgsEntry &lhs, const TKernelTypeStrArgsEntry &rhs) {
    return !(lhs == rhs);
}


inline TKernelTypeStrArgsEntry::TKernelTypeStrArgsEntry(const TKernelTypeStrArgsEntry &o)
      : kernel_type_str(o.kernel_type_str) {
  args.reserve(o.args.size());
  for (const auto &args_ : o.args) { args.emplace_back((args_) ? new onnxruntime::fbs::TArgTypeAndIndex(*args_) : nullptr); }
}

inline TKernelTypeStrArgsEntry &TKernelTypeStrArgsEntry::operator=(TKernelTypeStrArgsEntry o) FLATBUFFERS_NOEXCEPT {
  std::swap(kernel_type_str, o.kernel_type_str);
  std::swap(args, o.args);
  return *this;
}

inline TKernelTypeStrArgsEntry *KernelTypeStrArgsEntry::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TKernelTypeStrArgsEntry>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void KernelTypeStrArgsEntry::UnPackTo(TKernelTypeStrArgsEntry *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernel_type_str(); if (_e) _o->kernel_type_str = _e->str(); }
  { auto _e = args(); if (_e) { _o->args.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->args[_i]) { _e->Get(_i)->UnPackTo(_o->args[_i].get(), _resolver); } else { _o->args[_i] = std::unique_ptr<onnxruntime::fbs::TArgTypeAndIndex>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->args.resize(0); } }
}

inline ::flatbuffers::Offset<KernelTypeStrArgsEntry> KernelTypeStrArgsEntry::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TKernelTypeStrArgsEntry* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKernelTypeStrArgsEntry(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<KernelTypeStrArgsEntry> CreateKernelTypeStrArgsEntry(::flatbuffers::FlatBufferBuilder &_fbb, const TKernelTypeStrArgsEntry *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TKernelTypeStrArgsEntry* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernel_type_str = _fbb.CreateString(_o->kernel_type_str);
  auto _args = _o->args.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> (_o->args.size(), [](size_t i, _VectorArgs *__va) { return CreateArgTypeAndIndex(*__va->__fbb, __va->__o->args[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateKernelTypeStrArgsEntry(
      _fbb,
      _kernel_type_str,
      _args);
}


inline bool operator==(const TOpIdKernelTypeStrArgsEntry &lhs, const TOpIdKernelTypeStrArgsEntry &rhs) {
  return
      (lhs.op_id == rhs.op_id) &&
      (lhs.kernel_type_str_args.size() == rhs.kernel_type_str_args.size() && std::equal(lhs.kernel_type_str_args.cbegin(), lhs.kernel_type_str_args.cend(), rhs.kernel_type_str_args.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TKernelTypeStrArgsEntry> const &a, std::unique_ptr<onnxruntime::fbs::TKernelTypeStrArgsEntry> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TOpIdKernelTypeStrArgsEntry &lhs, const TOpIdKernelTypeStrArgsEntry &rhs) {
    return !(lhs == rhs);
}


inline TOpIdKernelTypeStrArgsEntry::TOpIdKernelTypeStrArgsEntry(const TOpIdKernelTypeStrArgsEntry &o)
      : op_id(o.op_id) {
  kernel_type_str_args.reserve(o.kernel_type_str_args.size());
  for (const auto &kernel_type_str_args_ : o.kernel_type_str_args) { kernel_type_str_args.emplace_back((kernel_type_str_args_) ? new onnxruntime::fbs::TKernelTypeStrArgsEntry(*kernel_type_str_args_) : nullptr); }
}

inline TOpIdKernelTypeStrArgsEntry &TOpIdKernelTypeStrArgsEntry::operator=(TOpIdKernelTypeStrArgsEntry o) FLATBUFFERS_NOEXCEPT {
  std::swap(op_id, o.op_id);
  std::swap(kernel_type_str_args, o.kernel_type_str_args);
  return *this;
}

inline TOpIdKernelTypeStrArgsEntry *OpIdKernelTypeStrArgsEntry::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TOpIdKernelTypeStrArgsEntry>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpIdKernelTypeStrArgsEntry::UnPackTo(TOpIdKernelTypeStrArgsEntry *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op_id(); if (_e) _o->op_id = _e->str(); }
  { auto _e = kernel_type_str_args(); if (_e) { _o->kernel_type_str_args.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->kernel_type_str_args[_i]) { _e->Get(_i)->UnPackTo(_o->kernel_type_str_args[_i].get(), _resolver); } else { _o->kernel_type_str_args[_i] = std::unique_ptr<onnxruntime::fbs::TKernelTypeStrArgsEntry>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->kernel_type_str_args.resize(0); } }
}

inline ::flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> OpIdKernelTypeStrArgsEntry::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TOpIdKernelTypeStrArgsEntry* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpIdKernelTypeStrArgsEntry(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> CreateOpIdKernelTypeStrArgsEntry(::flatbuffers::FlatBufferBuilder &_fbb, const TOpIdKernelTypeStrArgsEntry *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TOpIdKernelTypeStrArgsEntry* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op_id = _fbb.CreateString(_o->op_id);
  auto _kernel_type_str_args = _o->kernel_type_str_args.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> (_o->kernel_type_str_args.size(), [](size_t i, _VectorArgs *__va) { return CreateKernelTypeStrArgsEntry(*__va->__fbb, __va->__o->kernel_type_str_args[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateOpIdKernelTypeStrArgsEntry(
      _fbb,
      _op_id,
      _kernel_type_str_args);
}


inline bool operator==(const TKernelTypeStrResolver &lhs, const TKernelTypeStrResolver &rhs) {
  return
      (lhs.op_kernel_type_str_args.size() == rhs.op_kernel_type_str_args.size() && std::equal(lhs.op_kernel_type_str_args.cbegin(), lhs.op_kernel_type_str_args.cend(), rhs.op_kernel_type_str_args.cbegin(), [](std::unique_ptr<onnxruntime::fbs::TOpIdKernelTypeStrArgsEntry> const &a, std::unique_ptr<onnxruntime::fbs::TOpIdKernelTypeStrArgsEntry> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const TKernelTypeStrResolver &lhs, const TKernelTypeStrResolver &rhs) {
    return !(lhs == rhs);
}


inline TKernelTypeStrResolver::TKernelTypeStrResolver(const TKernelTypeStrResolver &o) {
  op_kernel_type_str_args.reserve(o.op_kernel_type_str_args.size());
  for (const auto &op_kernel_type_str_args_ : o.op_kernel_type_str_args) { op_kernel_type_str_args.emplace_back((op_kernel_type_str_args_) ? new onnxruntime::fbs::TOpIdKernelTypeStrArgsEntry(*op_kernel_type_str_args_) : nullptr); }
}

inline TKernelTypeStrResolver &TKernelTypeStrResolver::operator=(TKernelTypeStrResolver o) FLATBUFFERS_NOEXCEPT {
  std::swap(op_kernel_type_str_args, o.op_kernel_type_str_args);
  return *this;
}

inline TKernelTypeStrResolver *KernelTypeStrResolver::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TKernelTypeStrResolver>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void KernelTypeStrResolver::UnPackTo(TKernelTypeStrResolver *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op_kernel_type_str_args(); if (_e) { _o->op_kernel_type_str_args.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->op_kernel_type_str_args[_i]) { _e->Get(_i)->UnPackTo(_o->op_kernel_type_str_args[_i].get(), _resolver); } else { _o->op_kernel_type_str_args[_i] = std::unique_ptr<onnxruntime::fbs::TOpIdKernelTypeStrArgsEntry>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->op_kernel_type_str_args.resize(0); } }
}

inline ::flatbuffers::Offset<KernelTypeStrResolver> KernelTypeStrResolver::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TKernelTypeStrResolver* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKernelTypeStrResolver(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<KernelTypeStrResolver> CreateKernelTypeStrResolver(::flatbuffers::FlatBufferBuilder &_fbb, const TKernelTypeStrResolver *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TKernelTypeStrResolver* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op_kernel_type_str_args = _o->op_kernel_type_str_args.size() ? _fbb.CreateVector<::flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> (_o->op_kernel_type_str_args.size(), [](size_t i, _VectorArgs *__va) { return CreateOpIdKernelTypeStrArgsEntry(*__va->__fbb, __va->__o->op_kernel_type_str_args[i].get(), __va->__rehasher); }, &_va ) : 0;
  return onnxruntime::fbs::CreateKernelTypeStrResolver(
      _fbb,
      _op_kernel_type_str_args);
}


inline bool operator==(const TInferenceSession &lhs, const TInferenceSession &rhs) {
  return
      (lhs.ort_version == rhs.ort_version) &&
      ((lhs.model == rhs.model) || (lhs.model && rhs.model && *lhs.model == *rhs.model)) &&
      ((lhs.kernel_type_str_resolver == rhs.kernel_type_str_resolver) || (lhs.kernel_type_str_resolver && rhs.kernel_type_str_resolver && *lhs.kernel_type_str_resolver == *rhs.kernel_type_str_resolver));
}

inline bool operator!=(const TInferenceSession &lhs, const TInferenceSession &rhs) {
    return !(lhs == rhs);
}


inline TInferenceSession::TInferenceSession(const TInferenceSession &o)
      : ort_version(o.ort_version),
        model((o.model) ? new onnxruntime::fbs::TModel(*o.model) : nullptr),
        kernel_type_str_resolver((o.kernel_type_str_resolver) ? new onnxruntime::fbs::TKernelTypeStrResolver(*o.kernel_type_str_resolver) : nullptr) {
}

inline TInferenceSession &TInferenceSession::operator=(TInferenceSession o) FLATBUFFERS_NOEXCEPT {
  std::swap(ort_version, o.ort_version);
  std::swap(model, o.model);
  std::swap(kernel_type_str_resolver, o.kernel_type_str_resolver);
  return *this;
}

inline TInferenceSession *InferenceSession::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TInferenceSession>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InferenceSession::UnPackTo(TInferenceSession *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ort_version(); if (_e) _o->ort_version = _e->str(); }
  { auto _e = model(); if (_e) { if(_o->model) { _e->UnPackTo(_o->model.get(), _resolver); } else { _o->model = std::unique_ptr<onnxruntime::fbs::TModel>(_e->UnPack(_resolver)); } } else if (_o->model) { _o->model.reset(); } }
  { auto _e = kernel_type_str_resolver(); if (_e) { if(_o->kernel_type_str_resolver) { _e->UnPackTo(_o->kernel_type_str_resolver.get(), _resolver); } else { _o->kernel_type_str_resolver = std::unique_ptr<onnxruntime::fbs::TKernelTypeStrResolver>(_e->UnPack(_resolver)); } } else if (_o->kernel_type_str_resolver) { _o->kernel_type_str_resolver.reset(); } }
}

inline ::flatbuffers::Offset<InferenceSession> InferenceSession::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TInferenceSession* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInferenceSession(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<InferenceSession> CreateInferenceSession(::flatbuffers::FlatBufferBuilder &_fbb, const TInferenceSession *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TInferenceSession* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ort_version = _o->ort_version.empty() ? 0 : _fbb.CreateString(_o->ort_version);
  auto _model = _o->model ? CreateModel(_fbb, _o->model.get(), _rehasher) : 0;
  auto _kernel_type_str_resolver = _o->kernel_type_str_resolver ? CreateKernelTypeStrResolver(_fbb, _o->kernel_type_str_resolver.get(), _rehasher) : 0;
  return onnxruntime::fbs::CreateInferenceSession(
      _fbb,
      _ort_version,
      _model,
      _kernel_type_str_resolver);
}

inline bool VerifyTypeInfoValue(::flatbuffers::Verifier &verifier, const void *obj, TypeInfoValue type) {
  switch (type) {
    case TypeInfoValue::NONE: {
      return true;
    }
    case TypeInfoValue::tensor_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::TensorTypeAndShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TypeInfoValue::sequence_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::SequenceType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TypeInfoValue::map_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::MapType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeInfoValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<TypeInfoValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTypeInfoValue(
        verifier,  values->Get(i), types->GetEnum<TypeInfoValue>(i))) {
      return false;
    }
  }
  return true;
}

inline void *TypeInfoValueUnion::UnPack(const void *obj, TypeInfoValue type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case TypeInfoValue::tensor_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::TensorTypeAndShape *>(obj);
      return ptr->UnPack(resolver);
    }
    case TypeInfoValue::sequence_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::SequenceType *>(obj);
      return ptr->UnPack(resolver);
    }
    case TypeInfoValue::map_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::MapType *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> TypeInfoValueUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case TypeInfoValue::tensor_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::TTensorTypeAndShape *>(value);
      return CreateTensorTypeAndShape(_fbb, ptr, _rehasher).Union();
    }
    case TypeInfoValue::sequence_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::TSequenceType *>(value);
      return CreateSequenceType(_fbb, ptr, _rehasher).Union();
    }
    case TypeInfoValue::map_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::TMapType *>(value);
      return CreateMapType(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline TypeInfoValueUnion::TypeInfoValueUnion(const TypeInfoValueUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case TypeInfoValue::tensor_type: {
      value = new onnxruntime::fbs::TTensorTypeAndShape(*reinterpret_cast<onnxruntime::fbs::TTensorTypeAndShape *>(u.value));
      break;
    }
    case TypeInfoValue::sequence_type: {
      value = new onnxruntime::fbs::TSequenceType(*reinterpret_cast<onnxruntime::fbs::TSequenceType *>(u.value));
      break;
    }
    case TypeInfoValue::map_type: {
      value = new onnxruntime::fbs::TMapType(*reinterpret_cast<onnxruntime::fbs::TMapType *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void TypeInfoValueUnion::Reset() {
  switch (type) {
    case TypeInfoValue::tensor_type: {
      auto ptr = reinterpret_cast<onnxruntime::fbs::TTensorTypeAndShape *>(value);
      delete ptr;
      break;
    }
    case TypeInfoValue::sequence_type: {
      auto ptr = reinterpret_cast<onnxruntime::fbs::TSequenceType *>(value);
      delete ptr;
      break;
    }
    case TypeInfoValue::map_type: {
      auto ptr = reinterpret_cast<onnxruntime::fbs::TMapType *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = TypeInfoValue::NONE;
}

inline const ::flatbuffers::TypeTable *AttributeTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::AttributeTypeTypeTable
  };
  static const char * const names[] = {
    "UNDEFINED",
    "FLOAT",
    "INT",
    "STRING",
    "TENSOR",
    "GRAPH",
    "FLOATS",
    "INTS",
    "STRINGS",
    "TENSORS",
    "GRAPHS",
    "SPARSE_TENSOR",
    "SPARSE_TENSORS"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 13, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DimensionValueTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::DimensionValueTypeTypeTable
  };
  static const char * const names[] = {
    "UNKNOWN",
    "VALUE",
    "PARAM"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorDataTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TensorDataTypeTypeTable
  };
  static const char * const names[] = {
    "UNDEFINED",
    "FLOAT",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "INT32",
    "INT64",
    "STRING",
    "BOOL",
    "FLOAT16",
    "DOUBLE",
    "UINT32",
    "UINT64",
    "COMPLEX64",
    "COMPLEX128",
    "BFLOAT16",
    "FLOAT8E4M3FN",
    "FLOAT8E4M3FNUZ",
    "FLOAT8E5M2",
    "FLOAT8E5M2FNUZ"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 21, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NodeTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::NodeTypeTypeTable
  };
  static const char * const names[] = {
    "Primitive",
    "Fused"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TypeInfoValueTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TensorTypeAndShapeTypeTable,
    onnxruntime::fbs::SequenceTypeTypeTable,
    onnxruntime::fbs::MapTypeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "tensor_type",
    "sequence_type",
    "map_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArgTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::ArgTypeTypeTable
  };
  static const char * const names[] = {
    "INPUT",
    "OUTPUT"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ShapeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::DimensionTypeTable
  };
  static const char * const names[] = {
    "dim"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DimensionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::DimensionValueTypeTable
  };
  static const char * const names[] = {
    "value",
    "denotation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DimensionValueTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::DimensionValueTypeTypeTable
  };
  static const char * const names[] = {
    "dim_type",
    "dim_value",
    "dim_param"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorTypeAndShapeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TensorDataTypeTypeTable,
    onnxruntime::fbs::ShapeTypeTable
  };
  static const char * const names[] = {
    "elem_type",
    "shape"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MapTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TensorDataTypeTypeTable,
    onnxruntime::fbs::TypeInfoTypeTable
  };
  static const char * const names[] = {
    "key_type",
    "value_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SequenceTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TypeInfoTypeTable
  };
  static const char * const names[] = {
    "elem_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *EdgeEndTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12 };
  static const char * const names[] = {
    "node_index",
    "src_arg_index",
    "dst_arg_index"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NodeEdgeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::EdgeEndTypeTable
  };
  static const char * const names[] = {
    "node_index",
    "input_edges",
    "output_edges"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NodeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_INT, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::NodeTypeTypeTable,
    onnxruntime::fbs::AttributeTypeTable
  };
  static const char * const names[] = {
    "name",
    "doc_string",
    "domain",
    "since_version",
    "index",
    "op_type",
    "type",
    "execution_provider_type",
    "inputs",
    "outputs",
    "attributes",
    "input_arg_counts",
    "implicit_inputs"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ValueInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TypeInfoTypeTable
  };
  static const char * const names[] = {
    "name",
    "doc_string",
    "type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TypeInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UTYPE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TypeInfoValueTypeTable
  };
  static const char * const names[] = {
    "denotation",
    "value_type",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OperatorSetIdTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "domain",
    "version"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TensorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TensorDataTypeTypeTable
  };
  static const char * const names[] = {
    "name",
    "doc_string",
    "dims",
    "data_type",
    "raw_data",
    "string_data"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SparseTensorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_LONG, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TensorTypeTable
  };
  static const char * const names[] = {
    "values",
    "indices",
    "dims"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AttributeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::AttributeTypeTypeTable,
    onnxruntime::fbs::TensorTypeTable,
    onnxruntime::fbs::GraphTypeTable
  };
  static const char * const names[] = {
    "name",
    "doc_string",
    "type",
    "f",
    "i",
    "s",
    "t",
    "g",
    "floats",
    "ints",
    "strings",
    "tensors",
    "graphs"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NodesToOptimizeIndicesTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 1, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "node_indices",
    "num_inputs",
    "num_outputs",
    "has_variadic_input",
    "has_variadic_output",
    "num_variadic_inputs",
    "num_variadic_outputs"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DeprecatedNodeIndexAndKernelDefHashTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "node_index",
    "kernel_def_hash"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RuntimeOptimizationRecordTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::NodesToOptimizeIndicesTypeTable,
    onnxruntime::fbs::DeprecatedNodeIndexAndKernelDefHashTypeTable
  };
  static const char * const names[] = {
    "action_id",
    "nodes_to_optimize_indices",
    "produced_nodes",
    "produced_op_ids"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RuntimeOptimizationRecordContainerEntryTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::RuntimeOptimizationRecordTypeTable
  };
  static const char * const names[] = {
    "optimizer_name",
    "runtime_optimization_records"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RuntimeOptimizationsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::RuntimeOptimizationRecordContainerEntryTypeTable
  };
  static const char * const names[] = {
    "records"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *GraphTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 },
    { ::flatbuffers::ET_SEQUENCE, 0, 5 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::TensorTypeTable,
    onnxruntime::fbs::ValueInfoTypeTable,
    onnxruntime::fbs::NodeTypeTable,
    onnxruntime::fbs::NodeEdgeTypeTable,
    onnxruntime::fbs::SparseTensorTypeTable,
    onnxruntime::fbs::RuntimeOptimizationsTypeTable
  };
  static const char * const names[] = {
    "initializers",
    "node_args",
    "nodes",
    "max_node_index",
    "node_edges",
    "inputs",
    "outputs",
    "sparse_initializers",
    "runtime_optimizations"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *StringStringEntryTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "key",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ModelTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::OperatorSetIdTypeTable,
    onnxruntime::fbs::GraphTypeTable,
    onnxruntime::fbs::StringStringEntryTypeTable
  };
  static const char * const names[] = {
    "ir_version",
    "opset_import",
    "producer_name",
    "producer_version",
    "domain",
    "model_version",
    "doc_string",
    "graph",
    "graph_doc_string",
    "metadata_props"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DeprecatedKernelCreateInfosTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 1, -1 },
    { ::flatbuffers::ET_ULONG, 1, -1 }
  };
  static const char * const names[] = {
    "node_indices",
    "kernel_def_hashes"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DeprecatedSubGraphSessionStateTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::DeprecatedSessionStateTypeTable
  };
  static const char * const names[] = {
    "graph_id",
    "session_state"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DeprecatedSessionStateTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::DeprecatedKernelCreateInfosTypeTable,
    onnxruntime::fbs::DeprecatedSubGraphSessionStateTypeTable
  };
  static const char * const names[] = {
    "kernels",
    "sub_graph_session_states"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArgTypeAndIndexTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::ArgTypeTypeTable
  };
  static const char * const names[] = {
    "arg_type",
    "index"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *KernelTypeStrArgsEntryTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::ArgTypeAndIndexTypeTable
  };
  static const char * const names[] = {
    "kernel_type_str",
    "args"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OpIdKernelTypeStrArgsEntryTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::KernelTypeStrArgsEntryTypeTable
  };
  static const char * const names[] = {
    "op_id",
    "kernel_type_str_args"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *KernelTypeStrResolverTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::OpIdKernelTypeStrArgsEntryTypeTable
  };
  static const char * const names[] = {
    "op_kernel_type_str_args"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *InferenceSessionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    onnxruntime::fbs::ModelTypeTable,
    onnxruntime::fbs::DeprecatedSessionStateTypeTable,
    onnxruntime::fbs::KernelTypeStrResolverTypeTable
  };
  static const char * const names[] = {
    "ort_version",
    "model",
    "session_state",
    "kernel_type_str_resolver"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const onnxruntime::fbs::InferenceSession *GetInferenceSession(const void *buf) {
  return ::flatbuffers::GetRoot<onnxruntime::fbs::InferenceSession>(buf);
}

inline const onnxruntime::fbs::InferenceSession *GetSizePrefixedInferenceSession(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<onnxruntime::fbs::InferenceSession>(buf);
}

inline InferenceSession *GetMutableInferenceSession(void *buf) {
  return ::flatbuffers::GetMutableRoot<InferenceSession>(buf);
}

inline onnxruntime::fbs::InferenceSession *GetMutableSizePrefixedInferenceSession(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<onnxruntime::fbs::InferenceSession>(buf);
}

inline const char *InferenceSessionIdentifier() {
  return "ORTM";
}

inline bool InferenceSessionBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, InferenceSessionIdentifier());
}

inline bool SizePrefixedInferenceSessionBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, InferenceSessionIdentifier(), true);
}

inline bool VerifyInferenceSessionBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<onnxruntime::fbs::InferenceSession>(InferenceSessionIdentifier());
}

inline bool VerifySizePrefixedInferenceSessionBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<onnxruntime::fbs::InferenceSession>(InferenceSessionIdentifier());
}

inline void FinishInferenceSessionBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::InferenceSession> root) {
  fbb.Finish(root, InferenceSessionIdentifier());
}

inline void FinishSizePrefixedInferenceSessionBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<onnxruntime::fbs::InferenceSession> root) {
  fbb.FinishSizePrefixed(root, InferenceSessionIdentifier());
}

inline std::unique_ptr<onnxruntime::fbs::TInferenceSession> UnPackInferenceSession(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<onnxruntime::fbs::TInferenceSession>(GetInferenceSession(buf)->UnPack(res));
}

inline std::unique_ptr<onnxruntime::fbs::TInferenceSession> UnPackSizePrefixedInferenceSession(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<onnxruntime::fbs::TInferenceSession>(GetSizePrefixedInferenceSession(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace onnxruntime

#endif  // FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_FBS_H_
