// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEST_NOS_TEST_H_
#define FLATBUFFERS_GENERATED_TEST_NOS_TEST_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "array"

namespace nos {
namespace Test {

struct TestStruct;

struct TestStruct2;

struct TestTable;
struct TestTableBuilder;
struct TTestTable;

bool operator==(const TestStruct &lhs, const TestStruct &rhs);
bool operator!=(const TestStruct &lhs, const TestStruct &rhs);
bool operator==(const TestStruct2 &lhs, const TestStruct2 &rhs);
bool operator!=(const TestStruct2 &lhs, const TestStruct2 &rhs);
bool operator==(const TTestTable &lhs, const TTestTable &rhs);
bool operator!=(const TTestTable &lhs, const TTestTable &rhs);

inline const ::flatbuffers::TypeTable *TestStructTypeTable();

inline const ::flatbuffers::TypeTable *TestStruct2TypeTable();

inline const ::flatbuffers::TypeTable *TestTableTypeTable();

enum class TestEnum : uint32_t {
  NONE = 0,
  TEST1 = 1,
  TEST2 = 2,
  MIN = NONE,
  MAX = TEST2
};

inline const TestEnum (&EnumValuesTestEnum())[3] {
  static const TestEnum values[] = {
    TestEnum::NONE,
    TestEnum::TEST1,
    TestEnum::TEST2
  };
  return values;
}

inline const char * const *EnumNamesTestEnum() {
  static const char * const names[4] = {
    "NONE",
    "TEST1",
    "TEST2",
    nullptr
  };
  return names;
}

inline const char *EnumNameTestEnum(TestEnum e) {
  if (::flatbuffers::IsOutRange(e, TestEnum::NONE, TestEnum::TEST2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTestEnum()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TestStruct FLATBUFFERS_FINAL_CLASS {
 private:
  float test1_;

 public:
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TestStructTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "nos.Test.TestStruct";
  }
  TestStruct()
      : test1_(0) {
  }
  TestStruct(float _test1)
      : test1_(::flatbuffers::EndianScalar(_test1)) {
  }
  float test1() const {
    return ::flatbuffers::EndianScalar(test1_);
  }
  void mutate_test1(float _test1) {
    ::flatbuffers::WriteScalar(&test1_, _test1);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return test1();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(TestStruct, 4);

inline bool operator==(const TestStruct &lhs, const TestStruct &rhs) {
  return
      (lhs.test1() == rhs.test1());
}

inline bool operator!=(const TestStruct &lhs, const TestStruct &rhs) {
    return !(lhs == rhs);
}


struct TestStruct::Traits {
  using type = TestStruct;
  static constexpr auto name = "TestStruct";
  static constexpr auto fully_qualified_name = "nos.Test.TestStruct";
  static constexpr size_t fields_number = 1;
  static constexpr std::array<const char *, fields_number> field_names = {
    "test1"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TestStruct2 FLATBUFFERS_FINAL_CLASS {
 private:
  nos::Test::TestStruct test1_;
  float test2_;

 public:
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TestStruct2TypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "nos.Test.TestStruct2";
  }
  TestStruct2()
      : test1_(),
        test2_(0) {
  }
  TestStruct2(const nos::Test::TestStruct &_test1, float _test2)
      : test1_(_test1),
        test2_(::flatbuffers::EndianScalar(_test2)) {
  }
  const nos::Test::TestStruct &test1() const {
    return test1_;
  }
  nos::Test::TestStruct &mutable_test1() {
    return test1_;
  }
  float test2() const {
    return ::flatbuffers::EndianScalar(test2_);
  }
  void mutate_test2(float _test2) {
    ::flatbuffers::WriteScalar(&test2_, _test2);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return test1();
    else if constexpr (Index == 1) return test2();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(TestStruct2, 8);

inline bool operator==(const TestStruct2 &lhs, const TestStruct2 &rhs) {
  return
      (lhs.test1() == rhs.test1()) &&
      (lhs.test2() == rhs.test2());
}

inline bool operator!=(const TestStruct2 &lhs, const TestStruct2 &rhs) {
    return !(lhs == rhs);
}


struct TestStruct2::Traits {
  using type = TestStruct2;
  static constexpr auto name = "TestStruct2";
  static constexpr auto fully_qualified_name = "nos.Test.TestStruct2";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "test1",
    "test2"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct TTestTable : public ::flatbuffers::NativeTable {
  typedef TestTable TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "nos.Test.TTestTable";
  }
  std::string test1{};
  std::unique_ptr<nos::Test::TestStruct2> test2{};
  TTestTable() = default;
  TTestTable(const TTestTable &o);
  TTestTable(TTestTable&&) FLATBUFFERS_NOEXCEPT = default;
  TTestTable &operator=(TTestTable o) FLATBUFFERS_NOEXCEPT;
};

struct TestTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TTestTable NativeTableType;
  typedef TestTableBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TestTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "nos.Test.TestTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEST1 = 4,
    VT_TEST2 = 6
  };
  const ::flatbuffers::String *test1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEST1);
  }
  ::flatbuffers::String *mutable_test1() {
    return GetPointer<::flatbuffers::String *>(VT_TEST1);
  }
  const nos::Test::TestStruct2 *test2() const {
    return GetStruct<const nos::Test::TestStruct2 *>(VT_TEST2);
  }
  nos::Test::TestStruct2 *mutable_test2() {
    return GetStruct<nos::Test::TestStruct2 *>(VT_TEST2);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return test1();
    else if constexpr (Index == 1) return test2();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEST1) &&
           verifier.VerifyString(test1()) &&
           VerifyField<nos::Test::TestStruct2>(verifier, VT_TEST2, 4) &&
           verifier.EndTable();
  }
  TTestTable *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TTestTable *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TestTable> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTestTable* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestTableBuilder {
  typedef TestTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_test1(::flatbuffers::Offset<::flatbuffers::String> test1) {
    fbb_.AddOffset(TestTable::VT_TEST1, test1);
  }
  void add_test2(const nos::Test::TestStruct2 *test2) {
    fbb_.AddStruct(TestTable::VT_TEST2, test2);
  }
  explicit TestTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TestTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TestTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TestTable> CreateTestTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> test1 = 0,
    const nos::Test::TestStruct2 *test2 = nullptr) {
  TestTableBuilder builder_(_fbb);
  builder_.add_test2(test2);
  builder_.add_test1(test1);
  return builder_.Finish();
}

struct TestTable::Traits {
  using type = TestTable;
  static auto constexpr Create = CreateTestTable;
  static constexpr auto name = "TestTable";
  static constexpr auto fully_qualified_name = "nos.Test.TestTable";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "test1",
    "test2"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<TestTable> CreateTestTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *test1 = nullptr,
    const nos::Test::TestStruct2 *test2 = nullptr) {
  auto test1__ = test1 ? _fbb.CreateString(test1) : 0;
  return nos::Test::CreateTestTable(
      _fbb,
      test1__,
      test2);
}

::flatbuffers::Offset<TestTable> CreateTestTable(::flatbuffers::FlatBufferBuilder &_fbb, const TTestTable *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const TTestTable &lhs, const TTestTable &rhs) {
  return
      (lhs.test1 == rhs.test1) &&
      ((lhs.test2 == rhs.test2) || (lhs.test2 && rhs.test2 && *lhs.test2 == *rhs.test2));
}

inline bool operator!=(const TTestTable &lhs, const TTestTable &rhs) {
    return !(lhs == rhs);
}


inline TTestTable::TTestTable(const TTestTable &o)
      : test1(o.test1),
        test2((o.test2) ? new nos::Test::TestStruct2(*o.test2) : nullptr) {
}

inline TTestTable &TTestTable::operator=(TTestTable o) FLATBUFFERS_NOEXCEPT {
  std::swap(test1, o.test1);
  std::swap(test2, o.test2);
  return *this;
}

inline TTestTable *TestTable::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TTestTable>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TestTable::UnPackTo(TTestTable *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = test1(); if (_e) _o->test1 = _e->str(); }
  { auto _e = test2(); if (_e) _o->test2 = std::unique_ptr<nos::Test::TestStruct2>(new nos::Test::TestStruct2(*_e)); }
}

inline ::flatbuffers::Offset<TestTable> TestTable::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTestTable* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestTable(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TestTable> CreateTestTable(::flatbuffers::FlatBufferBuilder &_fbb, const TTestTable *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TTestTable* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _test1 = _o->test1.empty() ? 0 : _fbb.CreateString(_o->test1);
  auto _test2 = _o->test2 ? _o->test2.get() : nullptr;
  return nos::Test::CreateTestTable(
      _fbb,
      _test1,
      _test2);
}

inline const ::flatbuffers::TypeTable *TestEnumTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    nos::Test::TestEnumTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "TEST1",
    "TEST2"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TestStructTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4 };
  static const char * const names[] = {
    "test1"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 1, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TestStruct2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    nos::Test::TestStructTypeTable
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "test1",
    "test2"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TestTableTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    nos::Test::TestStruct2TypeTable
  };
  static const char * const names[] = {
    "test1",
    "test2"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace Test
}  // namespace nos

#endif  // FLATBUFFERS_GENERATED_TEST_NOS_TEST_H_
